
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sleap.nn.data.instance_cropping &#8212; SLEAP  documentation</title>
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for sleap.nn.data.instance_cropping</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Transformers for cropping instances for topdown processing.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">attr</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Text</span>
<span class="kn">import</span> <span class="nn">sleap</span>
<span class="kn">from</span> <span class="nn">sleap.nn.config</span> <span class="kn">import</span> <span class="n">InstanceCroppingConfig</span>


<div class="viewcode-block" id="find_instance_crop_size"><a class="viewcode-back" href="../../../../_autosummary/sleap.nn.data.instance_cropping.html#sleap.nn.data.instance_cropping.find_instance_crop_size">[docs]</a><span class="k">def</span> <span class="nf">find_instance_crop_size</span><span class="p">(</span>
    <span class="n">labels</span><span class="p">:</span> <span class="n">sleap</span><span class="o">.</span><span class="n">Labels</span><span class="p">,</span>
    <span class="n">padding</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">maximum_stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">input_scaling</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute the size of the largest instance bounding box from labels.</span>

<span class="sd">    Args:</span>
<span class="sd">        labels: A `sleap.Labels` containing user-labeled instances.</span>
<span class="sd">        padding: Integer number of pixels to add to the bounds as margin padding.</span>
<span class="sd">        maximum_stride: Ensure that the returned crop size is divisible by this value.</span>
<span class="sd">            Useful for ensuring that the crop size will not be truncated in a given</span>
<span class="sd">            architecture.</span>
<span class="sd">        input_scaling: Float factor indicating the scale of the input images if any</span>
<span class="sd">            scaling will be done before cropping.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An integer crop size denoting the length of the side of the bounding boxes that</span>
<span class="sd">        will contain the instances when cropped.</span>

<span class="sd">        This accounts for stride, padding and scaling when ensuring divisibility.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_length</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="n">labels</span><span class="o">.</span><span class="n">user_instances</span><span class="p">:</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">inst</span><span class="o">.</span><span class="n">points_array</span>
        <span class="n">pts</span> <span class="o">*=</span> <span class="n">input_scaling</span>
        <span class="n">max_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">max_length</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="n">max_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">max_length</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>

    <span class="n">max_length</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
    <span class="n">crop_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_length</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">maximum_stride</span><span class="p">))</span> <span class="o">*</span> <span class="n">maximum_stride</span>

    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">crop_size</span><span class="p">)</span></div>


<div class="viewcode-block" id="normalize_bboxes"><a class="viewcode-back" href="../../../../_autosummary/sleap.nn.data.instance_cropping.html#sleap.nn.data.instance_cropping.normalize_bboxes">[docs]</a><span class="k">def</span> <span class="nf">normalize_bboxes</span><span class="p">(</span>
    <span class="n">bboxes</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">image_height</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">image_width</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Normalize bounding box coordinates to the range [0, 1].</span>

<span class="sd">    This is useful for transforming points for TensorFlow operations that require</span>
<span class="sd">    normalized image coordinates.</span>

<span class="sd">    Args:</span>
<span class="sd">        bboxes: Tensor of shape (n_bboxes, 4) and dtype tf.float32, where the last axis</span>
<span class="sd">            corresponds to (y1, x1, y2, x2) coordinates of the bounding boxes.</span>
<span class="sd">        image_height: Scalar integer indicating the height of the image.</span>
<span class="sd">        image_width: Scalar integer indicating the width of the image.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor of the normalized points of the same shape as `bboxes`.</span>

<span class="sd">        The normalization applied to each point is `x / (image_width - 1)` and</span>
<span class="sd">        `y / (image_width - 1)`.</span>

<span class="sd">    See also: unnormalize_bboxes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compute normalizing factor of shape (1, 4).</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span>
            <span class="p">[[</span><span class="n">image_height</span><span class="p">,</span> <span class="n">image_width</span><span class="p">,</span> <span class="n">image_height</span><span class="p">,</span> <span class="n">image_width</span><span class="p">]],</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>
        <span class="o">-</span> <span class="mi">1</span>
    <span class="p">)</span>

    <span class="c1"># Normalize and return.</span>
    <span class="n">normalized_bboxes</span> <span class="o">=</span> <span class="n">bboxes</span> <span class="o">/</span> <span class="n">factor</span>
    <span class="k">return</span> <span class="n">normalized_bboxes</span></div>


<div class="viewcode-block" id="unnormalize_bboxes"><a class="viewcode-back" href="../../../../_autosummary/sleap.nn.data.instance_cropping.html#sleap.nn.data.instance_cropping.unnormalize_bboxes">[docs]</a><span class="k">def</span> <span class="nf">unnormalize_bboxes</span><span class="p">(</span>
    <span class="n">normalized_bboxes</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">image_height</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">image_width</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert bounding boxes coordinates in the range [0, 1] to absolute coordinates.</span>

<span class="sd">    Args:</span>
<span class="sd">        normalized_bboxes: Tensor of shape (n_bboxes, 4) and dtype tf.float32, where the</span>
<span class="sd">            last axis corresponds to (y1, x1, y2, x2) normalized coordinates of the</span>
<span class="sd">            bounding boxes in the range [0, 1].</span>
<span class="sd">        image_height: Scalar integer indicating the height of the image.</span>
<span class="sd">        image_width: Scalar integer indicating the width of the image.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor of the same shape as `bboxes` mapped back to absolute image coordinates</span>
<span class="sd">        by multiplying (x, y) coordinates by `(image_width - 1, image_height - 1)`.</span>

<span class="sd">    See also: normalize_bboxes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compute normalizing factor.</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span>
            <span class="p">[[</span><span class="n">image_height</span><span class="p">,</span> <span class="n">image_width</span><span class="p">,</span> <span class="n">image_height</span><span class="p">,</span> <span class="n">image_width</span><span class="p">]],</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>
        <span class="o">-</span> <span class="mi">1</span>
    <span class="p">)</span>

    <span class="c1"># Unnormalize and return.</span>
    <span class="n">bboxes</span> <span class="o">=</span> <span class="n">normalized_bboxes</span> <span class="o">*</span> <span class="n">factor</span>
    <span class="k">return</span> <span class="n">bboxes</span></div>


<div class="viewcode-block" id="make_centered_bboxes"><a class="viewcode-back" href="../../../../_autosummary/sleap.nn.data.instance_cropping.html#sleap.nn.data.instance_cropping.make_centered_bboxes">[docs]</a><span class="k">def</span> <span class="nf">make_centered_bboxes</span><span class="p">(</span>
    <span class="n">centroids</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">box_height</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">box_width</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Generate bounding boxes centered on a set of centroid coordinates.</span>

<span class="sd">    Args:</span>
<span class="sd">        centroids: A tensor of shape (n_centroids, 2) and dtype tf.float32, where the</span>
<span class="sd">            last axis corresponds to the (x, y) coordinates of each centroid.</span>
<span class="sd">        box_height: Scalar integer indicating the height of the bounding boxes.</span>
<span class="sd">        box_width: Scalar integer indicating the width of the bounding boxes.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor of shape (n_centroids, 4) and dtype tf.float32, where the last axis</span>
<span class="sd">        corresponds to (y1, x1, y2, x2) coordinates of the bounding boxes in absolute</span>
<span class="sd">        image coordinates.</span>

<span class="sd">    Notes:</span>
<span class="sd">        The bounding box coordinates are calculated such that the centroid coordinates</span>
<span class="sd">        map onto the center of the pixel. For example:</span>

<span class="sd">        For a single row image of shape (1, 4) with values: `[[a, b, c, d]]`, the x</span>
<span class="sd">        coordinates can be visualized in the diagram below:</span>
<span class="sd">                 _______________________</span>
<span class="sd">                |  a  |  b  |  c  |  d  |</span>
<span class="sd">                |  |  |  |  |  |  |  |  |</span>
<span class="sd">              -0.5 | 0.5 | 1.5 | 2.5 | 3.5</span>
<span class="sd">                   0     1     2     3</span>

<span class="sd">        To get a (1, 3) patch centered at c, the centroid would be at (x, y) = (2, 0)</span>
<span class="sd">        with box height of 1 and box width of 3, to yield `[[b, c, d]]`.</span>

<span class="sd">        For even sized bounding boxes, e.g., to get the center 2 elements, the centroid</span>
<span class="sd">        would be at (x, y) = (1.5, 0) with box width of 2, to yield `[[b, c]]`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">convert_to_tensor</span><span class="p">(</span>
            <span class="p">[[</span><span class="o">-</span><span class="n">box_height</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">box_width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">box_height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">box_width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]],</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="o">*</span> <span class="mf">0.5</span>
    <span class="p">)</span>
    <span class="n">bboxes</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">centroids</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">delta</span>
    <span class="k">return</span> <span class="n">bboxes</span></div>


<div class="viewcode-block" id="crop_bboxes"><a class="viewcode-back" href="../../../../_autosummary/sleap.nn.data.instance_cropping.html#sleap.nn.data.instance_cropping.crop_bboxes">[docs]</a><span class="k">def</span> <span class="nf">crop_bboxes</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">bboxes</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Crop bounding boxes from an image.</span>

<span class="sd">    This method serves as a convenience method for specifying the arguments of</span>
<span class="sd">    `tf.image.crop_and_resize`, becoming especially useful in the case of multiple</span>
<span class="sd">    bounding boxes with a single image and no resizing.</span>

<span class="sd">    Args:</span>
<span class="sd">        image: Tensor of shape (height, width, channels) of a single image.</span>
<span class="sd">        bboxes: Tensor of shape (n_bboxes, 4) and dtype tf.float32, where the last axis</span>
<span class="sd">            corresponds to (y1, x1, y2, x2) coordinates of the bounding boxes. This can</span>
<span class="sd">            be generated from centroids using `make_centered_bboxes`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tensor of shape (n_bboxes, crop_height, crop_width, channels) of the same</span>
<span class="sd">        dtype as the input image. The crop size is inferred from the bounding box</span>
<span class="sd">        coordinates.</span>

<span class="sd">    Notes:</span>
<span class="sd">        This function expects bounding boxes with coordinates at the centers of the</span>
<span class="sd">        pixels in the box limits. Technically, the box will span (x1 - 0.5, x2 + 0.5)</span>
<span class="sd">        and (y1 - 0.5, y2 + 0.5).</span>

<span class="sd">        For example, a 3x3 patch centered at (1, 1) would be specified by</span>
<span class="sd">        (y1, x1, y2, x2) = (0, 0, 2, 2). This would be exactly equivalent to indexing</span>
<span class="sd">        the image with `image[0:3, 0:3]`.</span>

<span class="sd">    See also: `make_centered_bboxes`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compute bounding box size to use for crops.</span>
    <span class="n">y1x1</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather_nd</span><span class="p">(</span><span class="n">bboxes</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
    <span class="n">y2x2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather_nd</span><span class="p">(</span><span class="n">bboxes</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
    <span class="n">box_size</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">y2x2</span> <span class="o">-</span> <span class="n">y1x1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>  <span class="c1"># (height, width)</span>

    <span class="c1"># Normalize bounding boxes.</span>
    <span class="n">image_height</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">image</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">image_width</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">image</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">normalized_bboxes</span> <span class="o">=</span> <span class="n">normalize_bboxes</span><span class="p">(</span>
        <span class="n">bboxes</span><span class="p">,</span> <span class="n">image_height</span><span class="o">=</span><span class="n">image_height</span><span class="p">,</span> <span class="n">image_width</span><span class="o">=</span><span class="n">image_width</span>
    <span class="p">)</span>

    <span class="c1"># Crop.</span>
    <span class="n">crops</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">crop_and_resize</span><span class="p">(</span>
        <span class="n">image</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">boxes</span><span class="o">=</span><span class="n">normalized_bboxes</span><span class="p">,</span>
        <span class="n">box_indices</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">bboxes</span><span class="p">)[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
        <span class="n">crop_size</span><span class="o">=</span><span class="n">box_size</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;bilinear&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Cast back to original dtype and return.</span>
    <span class="n">crops</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">crops</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">crops</span></div>


<div class="viewcode-block" id="InstanceCropper"><a class="viewcode-back" href="../../../../_autosummary/sleap.nn.data.instance_cropping.html#sleap.nn.data.instance_cropping.InstanceCropper">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">InstanceCropper</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Data transformer to crop and generate individual examples for instances.</span>

<span class="sd">    This generates datasets that are instance cropped for topdown processing.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        crop_width: Width of the crops in pixels.</span>
<span class="sd">        crop_height: Height of the crops in pixels.</span>
<span class="sd">        keep_full_image: If True, the output examples will contain the full images</span>
<span class="sd">            provided as input to the instance cropped. This can be useful for pipelines</span>
<span class="sd">            that use both full and cropped images, at the cost of increased memory</span>
<span class="sd">            requirements usage. Setting this to False can substantially improve</span>
<span class="sd">            performance of large pipelines if the full images are no longer required.</span>
<span class="sd">        mock_centroid_confidence: If True, add confidence keys for compatibility with</span>
<span class="sd">            predicted instance cropping.</span>
<span class="sd">        unbatch: If True (the default), split frame-level examples into multiple</span>
<span class="sd">            instance-level examples. If False, all instance crops will be kept within</span>
<span class="sd">            the same example. Use this when building pipelines that require knowledge</span>
<span class="sd">            about all instances within a single example.</span>
<span class="sd">        image_key: Name of the example key where the image is stored. Defaults to</span>
<span class="sd">            &quot;image&quot;.</span>
<span class="sd">        instances_key: Name of the example key where the instance points are stored.</span>
<span class="sd">            Defaults to &quot;instances&quot;.</span>
<span class="sd">        centroids_key: Name of the example key where the instance centroids are stored.</span>
<span class="sd">            Defaults to &quot;centroids&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">crop_width</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">crop_height</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">keep_full_image</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">mock_centroid_confidence</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">unbatch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">image_key</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s2">&quot;image&quot;</span>
    <span class="n">instances_key</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s2">&quot;instances&quot;</span>
    <span class="n">centroids_key</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s2">&quot;centroids&quot;</span>

<div class="viewcode-block" id="InstanceCropper.from_config"><a class="viewcode-back" href="../../../../_autosummary/sleap.nn.data.instance_cropping.html#sleap.nn.data.instance_cropping.InstanceCropper.from_config">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_config</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="n">InstanceCroppingConfig</span><span class="p">,</span> <span class="n">crop_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;InstanceCropper&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Build an instance of this class from its configuration options.</span>

<span class="sd">        Args:</span>
<span class="sd">            config: An `InstanceCroppingConfig` instance with the desired parameters.</span>
<span class="sd">            crop_size: Integer specifying the crop height and width. This is only</span>
<span class="sd">                required and will only be used if the `config.crop_size` attribute does</span>
<span class="sd">                not specify an explicit integer crop size (e.g., it is set to None).</span>

<span class="sd">        Returns:</span>
<span class="sd">            An instance of this class.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the `crop_size` is not specified in either the config</span>
<span class="sd">                attribute or function arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">crop_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">crop_size</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">crop_size</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crop_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Crop size not specified in config and not provided in the arguments.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">crop_width</span><span class="o">=</span><span class="n">crop_size</span><span class="p">,</span> <span class="n">crop_height</span><span class="o">=</span><span class="n">crop_size</span><span class="p">,</span> <span class="n">keep_full_image</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Text</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return the keys that incoming elements are expected to have.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">image_key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">instances_key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroids_key</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">output_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Text</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return the keys that outgoing elements will have.&quot;&quot;&quot;</span>
        <span class="n">output_keys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;instance_image&quot;</span><span class="p">,</span>
            <span class="s2">&quot;bbox&quot;</span><span class="p">,</span>
            <span class="s2">&quot;center_instance&quot;</span><span class="p">,</span>
            <span class="s2">&quot;center_instance_ind&quot;</span><span class="p">,</span>
            <span class="s2">&quot;all_instances&quot;</span><span class="p">,</span>
            <span class="s2">&quot;centroid&quot;</span><span class="p">,</span>
            <span class="s2">&quot;full_image_height&quot;</span><span class="p">,</span>
            <span class="s2">&quot;full_image_width&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_full_image</span><span class="p">:</span>
            <span class="n">output_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_key</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mock_centroid_confidence</span><span class="p">:</span>
            <span class="n">output_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;centroid_confidence&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output_keys</span>

<div class="viewcode-block" id="InstanceCropper.transform_dataset"><a class="viewcode-back" href="../../../../_autosummary/sleap.nn.data.instance_cropping.html#sleap.nn.data.instance_cropping.InstanceCropper.transform_dataset">[docs]</a>    <span class="k">def</span> <span class="nf">transform_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_ds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a dataset that contains instance cropped data.</span>

<span class="sd">        Args:</span>
<span class="sd">            ds_input: A dataset with examples containing the following keys:</span>
<span class="sd">                &quot;image&quot;: The full image in a tensor of shape (height, width, channels).</span>
<span class="sd">                &quot;instances&quot;: Instance points in a tf.float32 tensor of shape</span>
<span class="sd">                    (n_instances, n_nodes, 2).</span>
<span class="sd">                &quot;centroids&quot;: The computed centroid for each instance in a tf.float32</span>
<span class="sd">                    tensor of shape (n_instances, 2).</span>
<span class="sd">                Any additional keys present will be replicated in each output.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A `tf.data.Dataset` with elements containing instance cropped data. Each</span>
<span class="sd">            instance will generate an example, so the total number of elements may</span>
<span class="sd">            change relative to the input dataset.</span>

<span class="sd">            Each element in the output dataset will have the following keys:</span>
<span class="sd">                &quot;instance_image&quot;: A cropped image of the same dtype as the input image</span>
<span class="sd">                    but with shape (crop_width, crop_height, channels) and will be</span>
<span class="sd">                    centered on an instance.</span>
<span class="sd">                &quot;bbox&quot;: The bounding box in absolute image coordinates in the format</span>
<span class="sd">                    (y1, x1, y2, x2) that resulted in the cropped image in</span>
<span class="sd">                    &quot;instance_image&quot;. This will be a tf.float32 tensor of shape (4,).</span>
<span class="sd">                &quot;center_instance&quot;: The points of the centered instance in image</span>
<span class="sd">                    coordinates in the &quot;instance_image&quot;. This will be a tf.float32</span>
<span class="sd">                    tensor of shape (n_nodes, 2). The absolute image coordinates can be</span>
<span class="sd">                    recovered by adding (x1, y1) from the &quot;bbox&quot; key.</span>
<span class="sd">                &quot;center_instance_ind&quot;: Scalar tf.int32 index of the centered instance</span>
<span class="sd">                    relative to all the instances in the frame. This can be used to</span>
<span class="sd">                    index into additional keys that may contain data from all instances.</span>
<span class="sd">                &quot;all_instances&quot;: The points of all instances in the frame in image</span>
<span class="sd">                    coordinates in the &quot;instance_image&quot;. This will be a tf.float32</span>
<span class="sd">                    tensor of shape (n_instances, n_nodes, 2). This is useful for multi-</span>
<span class="sd">                    stage models that first predict all nodes and subsequently refine it</span>
<span class="sd">                    to just the centered instance. The &quot;center_instance_ind&quot;-th row of</span>
<span class="sd">                    this tensor is equal to &quot;center_instance&quot;.</span>
<span class="sd">                &quot;centroid&quot;: The centroid coordinate that was used to generate this crop,</span>
<span class="sd">                    specified as a tf.float32 tensor of shape (2,) in absolute image</span>
<span class="sd">                    coordinates.</span>
<span class="sd">                &quot;full_image_height&quot;: The height of the full image from which the crop</span>
<span class="sd">                    was generated, specified as a scalar tf.int32 tensor.</span>
<span class="sd">                &quot;full_image_width&quot;: The width of the full image from which the crop was</span>
<span class="sd">                    generated, specified as a scalar tf.int32 tensor.</span>

<span class="sd">            If `keep_full_image` is True, examples will also have an &quot;image&quot; key</span>
<span class="sd">            containing the same image as the input.</span>

<span class="sd">            if `mock_centroid_confidence` is True, examples will also have a</span>
<span class="sd">            &quot;centroid_confidence&quot; key with all ones. This is useful for evaluating</span>
<span class="sd">            models that use crops independently from centroid inference.</span>

<span class="sd">            Additional keys will be replicated in each example under the same name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Draw a test example from the input dataset to find extra keys to replicate.</span>
        <span class="n">test_example</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">input_ds</span><span class="p">))</span>
        <span class="n">keys_to_expand</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">test_example</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_keys</span>
        <span class="p">]</span>
        <span class="n">img_channels</span> <span class="o">=</span> <span class="n">test_example</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">image_key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_full_image</span><span class="p">:</span>
            <span class="n">keys_to_expand</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_key</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">crop_instances</span><span class="p">(</span><span class="n">frame_data</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Local processing function for dataset mapping.&quot;&quot;&quot;</span>
            <span class="c1"># Make bounding boxes from centroids.</span>
            <span class="n">bboxes</span> <span class="o">=</span> <span class="n">make_centered_bboxes</span><span class="p">(</span>
                <span class="n">frame_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">centroids_key</span><span class="p">],</span>
                <span class="n">box_height</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crop_height</span><span class="p">,</span>
                <span class="n">box_width</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crop_width</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Crop images from bounding boxes.</span>
            <span class="n">instance_images</span> <span class="o">=</span> <span class="n">crop_bboxes</span><span class="p">(</span><span class="n">frame_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">image_key</span><span class="p">],</span> <span class="n">bboxes</span><span class="p">)</span>

            <span class="c1"># Ensure shape is statically specified.</span>
            <span class="n">instance_images</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">ensure_shape</span><span class="p">(</span>
                <span class="n">instance_images</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop_height</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop_width</span><span class="p">,</span> <span class="n">img_channels</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Pull out the bbox offsets as (n_instances, 2) in xy order.</span>
            <span class="n">bboxes_x1y1</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">bboxes</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Expand the instance points to (n_instances, n_instances, n_nodes, 2).</span>
            <span class="n">n_instances</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">bboxes</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">all_instances</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">frame_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">instances_key</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                <span class="n">n_instances</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Subtract offsets such that each row is relative to an instance.</span>
            <span class="n">all_instances</span> <span class="o">=</span> <span class="n">all_instances</span> <span class="o">-</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">bboxes_x1y1</span><span class="p">,</span> <span class="p">[</span><span class="n">n_instances</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Pull out the centered instance from each row as (n_instances, n_nodes, 2).</span>
            <span class="n">center_instances</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather_nd</span><span class="p">(</span>
                <span class="n">all_instances</span><span class="p">,</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">tf</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">n_instances</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">n_instances</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
            <span class="p">)</span>

            <span class="c1"># Create multi-instance example.</span>
            <span class="n">instances_data</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;instance_image&quot;</span><span class="p">:</span> <span class="n">instance_images</span><span class="p">,</span>
                <span class="s2">&quot;bbox&quot;</span><span class="p">:</span> <span class="n">bboxes</span><span class="p">,</span>
                <span class="s2">&quot;center_instance&quot;</span><span class="p">:</span> <span class="n">center_instances</span><span class="p">,</span>
                <span class="s2">&quot;center_instance_ind&quot;</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">n_instances</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                <span class="s2">&quot;all_instances&quot;</span><span class="p">:</span> <span class="n">all_instances</span><span class="p">,</span>
                <span class="s2">&quot;centroid&quot;</span><span class="p">:</span> <span class="n">frame_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">centroids_key</span><span class="p">],</span>
                <span class="s2">&quot;full_image_height&quot;</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                    <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">frame_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">image_key</span><span class="p">])[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n_instances</span>
                <span class="p">),</span>
                <span class="s2">&quot;full_image_width&quot;</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                    <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">frame_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">image_key</span><span class="p">])[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_instances</span>
                <span class="p">),</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mock_centroid_confidence</span><span class="p">:</span>
                <span class="n">instances_data</span><span class="p">[</span><span class="s2">&quot;centroid_confidence&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">n_instances</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span>
                <span class="p">)</span>  <span class="c1"># (n_instances,)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys_to_expand</span><span class="p">:</span>
                <span class="n">instances_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                    <span class="n">tf</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">frame_data</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">n_instances</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">instances_data</span>

        <span class="c1"># Map the main processing function to each example.</span>
        <span class="n">output_ds</span> <span class="o">=</span> <span class="n">input_ds</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="n">crop_instances</span><span class="p">,</span> <span class="n">num_parallel_calls</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">AUTOTUNE</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unbatch</span><span class="p">:</span>
            <span class="c1"># Unbatch to split frame-level examples into individual instance-level</span>
            <span class="c1"># examples.</span>
            <span class="n">output_ds</span> <span class="o">=</span> <span class="n">output_ds</span><span class="o">.</span><span class="n">unbatch</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">output_ds</span></div></div>


<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">PredictedInstanceCropper</span><span class="p">:</span>

    <span class="n">crop_width</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">crop_height</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">centroids_key</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s2">&quot;predicted_centroids&quot;</span>
    <span class="n">centroid_confidences_key</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s2">&quot;predicted_centroid_confidences&quot;</span>
    <span class="n">full_image_key</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s2">&quot;full_image&quot;</span>
    <span class="n">full_image_scale_key</span><span class="p">:</span> <span class="n">Text</span> <span class="o">=</span> <span class="s2">&quot;full_image_scale&quot;</span>
    <span class="n">other_keys_to_keep</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Text</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">keep_instances_gt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Text</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return the keys that incoming elements are expected to have.&quot;&quot;&quot;</span>
        <span class="n">input_keys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_image_key</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_image_scale_key</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centroids_key</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centroid_confidences_key</span><span class="p">,</span>
            <span class="s2">&quot;video_ind&quot;</span><span class="p">,</span>
            <span class="s2">&quot;frame_ind&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_instances_gt</span><span class="p">:</span>
            <span class="n">input_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;instances&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">input_keys</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">output_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Text</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return the keys that outgoing elements will have.&quot;&quot;&quot;</span>
        <span class="n">output_keys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;instance_image&quot;</span><span class="p">,</span>
            <span class="s2">&quot;bbox&quot;</span><span class="p">,</span>
            <span class="s2">&quot;center_instance_ind&quot;</span><span class="p">,</span>
            <span class="s2">&quot;centroid&quot;</span><span class="p">,</span>
            <span class="s2">&quot;centroid_confidence&quot;</span><span class="p">,</span>
            <span class="s2">&quot;full_image_height&quot;</span><span class="p">,</span>
            <span class="s2">&quot;full_image_width&quot;</span><span class="p">,</span>
            <span class="s2">&quot;scale&quot;</span><span class="p">,</span>
            <span class="s2">&quot;video_ind&quot;</span><span class="p">,</span>
            <span class="s2">&quot;frame_ind&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">other_keys_to_keep</span><span class="p">:</span>
            <span class="n">output_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other_keys_to_keep</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_instances_gt</span><span class="p">:</span>
            <span class="n">output_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;instances&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output_keys</span>

    <span class="k">def</span> <span class="nf">transform_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_ds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a dataset that contains instance cropped data.&quot;&quot;&quot;</span>
        <span class="n">keys_to_expand</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="s2">&quot;video_ind&quot;</span><span class="p">,</span> <span class="s2">&quot;frame_ind&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">other_keys_to_keep</span><span class="p">:</span>
            <span class="n">keys_to_expand</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other_keys_to_keep</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_instances_gt</span><span class="p">:</span>
            <span class="n">keys_to_expand</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;instances&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">crop_instances</span><span class="p">(</span><span class="n">frame_data</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Local processing function for dataset mapping.&quot;&quot;&quot;</span>
            <span class="c1"># Make bounding boxes from centroids.</span>
            <span class="n">full_centroids</span> <span class="o">=</span> <span class="n">frame_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">centroids_key</span><span class="p">]</span> <span class="o">/</span> <span class="n">frame_data</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span>
            <span class="n">full_centroids</span> <span class="o">=</span> <span class="n">full_centroids</span> <span class="o">*</span> <span class="n">frame_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">full_image_scale_key</span><span class="p">]</span>
            <span class="n">bboxes</span> <span class="o">=</span> <span class="n">make_centered_bboxes</span><span class="p">(</span>
                <span class="n">full_centroids</span><span class="p">,</span> <span class="n">box_height</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crop_height</span><span class="p">,</span> <span class="n">box_width</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crop_width</span>
            <span class="p">)</span>

            <span class="n">frame_data</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">frame_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">full_image_scale_key</span><span class="p">]</span>

            <span class="c1"># Crop images from bounding boxes.</span>
            <span class="n">instance_images</span> <span class="o">=</span> <span class="n">crop_bboxes</span><span class="p">(</span><span class="n">frame_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">full_image_key</span><span class="p">],</span> <span class="n">bboxes</span><span class="p">)</span>
            <span class="n">n_instances</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">bboxes</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Create multi-instance example.</span>
            <span class="n">instances_data</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;instance_image&quot;</span><span class="p">:</span> <span class="n">instance_images</span><span class="p">,</span>
                <span class="s2">&quot;bbox&quot;</span><span class="p">:</span> <span class="n">bboxes</span><span class="p">,</span>
                <span class="s2">&quot;center_instance_ind&quot;</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">n_instances</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                <span class="s2">&quot;centroid&quot;</span><span class="p">:</span> <span class="n">full_centroids</span><span class="p">,</span>
                <span class="s2">&quot;centroid_confidence&quot;</span><span class="p">:</span> <span class="n">frame_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">centroid_confidences_key</span><span class="p">],</span>
                <span class="s2">&quot;full_image_height&quot;</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                    <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">frame_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">full_image_key</span><span class="p">])[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n_instances</span>
                <span class="p">),</span>
                <span class="s2">&quot;full_image_width&quot;</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                    <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">frame_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">full_image_key</span><span class="p">])[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_instances</span>
                <span class="p">),</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys_to_expand</span><span class="p">:</span>
                <span class="n">instances_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                    <span class="n">tf</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">frame_data</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">n_instances</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">instances_data</span>

        <span class="c1"># Map the main processing function to each example.</span>
        <span class="n">output_ds</span> <span class="o">=</span> <span class="n">input_ds</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="n">crop_instances</span><span class="p">,</span> <span class="n">num_parallel_calls</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">AUTOTUNE</span>
        <span class="p">)</span>

        <span class="c1"># Unbatch to split frame-level examples into individual instance-level examples.</span>
        <span class="n">output_ds</span> <span class="o">=</span> <span class="n">output_ds</span><span class="o">.</span><span class="n">unbatch</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">output_ds</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">SLEAP</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../guides/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../guides/index.html">Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../guides/reference.html">Feature Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api.html">API</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019–2020, Murthy Lab @ Princeton.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.4.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>