
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sleap.nn.inference &#8212; SLEAP  documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for sleap.nn.inference</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Inference pipelines and utilities.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">attr</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Text</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">sleap</span>
<span class="kn">from</span> <span class="nn">sleap</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">sleap.nn.config</span> <span class="kn">import</span> <span class="n">TrainingJobConfig</span>
<span class="kn">from</span> <span class="nn">sleap.nn.model</span> <span class="kn">import</span> <span class="n">Model</span>
<span class="kn">from</span> <span class="nn">sleap.nn.tracking</span> <span class="kn">import</span> <span class="n">Tracker</span><span class="p">,</span> <span class="n">run_tracker</span>
<span class="kn">from</span> <span class="nn">sleap.nn.paf_grouping</span> <span class="kn">import</span> <span class="n">PAFScorer</span>
<span class="kn">from</span> <span class="nn">sleap.nn.data.grouping</span> <span class="kn">import</span> <span class="n">group_examples_iter</span>
<span class="kn">from</span> <span class="nn">sleap.nn.data.pipelines</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Provider</span><span class="p">,</span>
    <span class="n">Pipeline</span><span class="p">,</span>
    <span class="n">LabelsReader</span><span class="p">,</span>
    <span class="n">VideoReader</span><span class="p">,</span>
    <span class="n">Normalizer</span><span class="p">,</span>
    <span class="n">Resizer</span><span class="p">,</span>
    <span class="n">Prefetcher</span><span class="p">,</span>
    <span class="n">LambdaFilter</span><span class="p">,</span>
    <span class="n">KerasModelPredictor</span><span class="p">,</span>
    <span class="n">LocalPeakFinder</span><span class="p">,</span>
    <span class="n">PredictedInstanceCropper</span><span class="p">,</span>
    <span class="n">InstanceCentroidFinder</span><span class="p">,</span>
    <span class="n">InstanceCropper</span><span class="p">,</span>
    <span class="n">GlobalPeakFinder</span><span class="p">,</span>
    <span class="n">MockGlobalPeakFinder</span><span class="p">,</span>
    <span class="n">KeyFilter</span><span class="p">,</span>
    <span class="n">KeyRenamer</span><span class="p">,</span>
    <span class="n">KeyDeviceMover</span><span class="p">,</span>
    <span class="n">PredictedCenterInstanceNormalizer</span><span class="p">,</span>
    <span class="n">PartAffinityFieldInstanceGrouper</span><span class="p">,</span>
    <span class="n">PointsRescaler</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="safely_generate"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.safely_generate">[docs]</a><span class="k">def</span> <span class="nf">safely_generate</span><span class="p">(</span><span class="n">ds</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">progress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Yields examples from dataset, catching and logging exceptions.&quot;&quot;&quot;</span>

    <span class="c1"># Unsafe generating:</span>
    <span class="c1"># for example in ds:</span>
    <span class="c1">#     yield example</span>

    <span class="n">ds_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">wall_t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">next_val</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">ds_iter</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">next_val</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ERROR in sample index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Show the current progress (frames, time, fps)</span>
            <span class="k">if</span> <span class="n">progress</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">done</span><span class="p">:</span>
                    <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">wall_t0</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Finished </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> examples in </span><span class="si">{</span><span class="n">elapsed_time</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds (inference + postprocessing)&quot;</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">elapsed_time</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;examples/s = </span><span class="si">{</span><span class="n">i</span><span class="o">/</span><span class="n">elapsed_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">make_grouped_labeled_frame</span><span class="p">(</span>
    <span class="n">video_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">frame_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">frame_examples</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Text</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]],</span>
    <span class="n">videos</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">sleap</span><span class="o">.</span><span class="n">Video</span><span class="p">],</span>
    <span class="n">skeleton</span><span class="p">:</span> <span class="s2">&quot;Skeleton&quot;</span><span class="p">,</span>
    <span class="n">points_key</span><span class="p">:</span> <span class="n">Text</span><span class="p">,</span>
    <span class="n">point_confidences_key</span><span class="p">:</span> <span class="n">Text</span><span class="p">,</span>
    <span class="n">image_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Text</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">instance_score_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Text</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">tracker</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tracker</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">sleap</span><span class="o">.</span><span class="n">LabeledFrame</span><span class="p">]:</span>

    <span class="n">predicted_frames</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Create predicted instances from examples in the current frame.</span>
    <span class="n">predicted_instances</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">img</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">frame_examples</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">instance_score_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">instance_scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">example</span><span class="p">[</span><span class="n">point_confidences_key</span><span class="p">]</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">instance_scores</span> <span class="o">=</span> <span class="n">example</span><span class="p">[</span><span class="n">instance_score_key</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">example</span><span class="p">[</span><span class="n">points_key</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">points</span><span class="p">,</span> <span class="n">confidences</span><span class="p">,</span> <span class="n">instance_score</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">example</span><span class="p">[</span><span class="n">points_key</span><span class="p">],</span> <span class="n">example</span><span class="p">[</span><span class="n">point_confidences_key</span><span class="p">],</span> <span class="n">instance_scores</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">predicted_instances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">sleap</span><span class="o">.</span><span class="n">PredictedInstance</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
                            <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span>
                            <span class="n">point_confidences</span><span class="o">=</span><span class="n">confidences</span><span class="p">,</span>
                            <span class="n">instance_score</span><span class="o">=</span><span class="n">instance_score</span><span class="p">,</span>
                            <span class="n">skeleton</span><span class="o">=</span><span class="n">skeleton</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">example</span><span class="p">[</span><span class="n">points_key</span><span class="p">]</span>
            <span class="n">confidences</span> <span class="o">=</span> <span class="n">example</span><span class="p">[</span><span class="n">point_confidences_key</span><span class="p">]</span>
            <span class="n">instance_score</span> <span class="o">=</span> <span class="n">instance_scores</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">predicted_instances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">sleap</span><span class="o">.</span><span class="n">PredictedInstance</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
                        <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span>
                        <span class="n">point_confidences</span><span class="o">=</span><span class="n">confidences</span><span class="p">,</span>
                        <span class="n">instance_score</span><span class="o">=</span><span class="n">instance_score</span><span class="p">,</span>
                        <span class="n">skeleton</span><span class="o">=</span><span class="n">skeleton</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">image_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">image_key</span> <span class="ow">in</span> <span class="n">example</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">example</span><span class="p">[</span><span class="n">image_key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">predicted_instances</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tracker</span><span class="p">:</span>
            <span class="c1"># Set tracks for predicted instances in this frame.</span>
            <span class="n">predicted_instances</span> <span class="o">=</span> <span class="n">tracker</span><span class="o">.</span><span class="n">track</span><span class="p">(</span>
                <span class="n">untracked_instances</span><span class="o">=</span><span class="n">predicted_instances</span><span class="p">,</span> <span class="n">img</span><span class="o">=</span><span class="n">img</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">frame_ind</span>
            <span class="p">)</span>

        <span class="c1"># Create labeled frame from predicted instances.</span>
        <span class="n">labeled_frame</span> <span class="o">=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">LabeledFrame</span><span class="p">(</span>
            <span class="n">video</span><span class="o">=</span><span class="n">videos</span><span class="p">[</span><span class="n">video_ind</span><span class="p">],</span> <span class="n">frame_idx</span><span class="o">=</span><span class="n">frame_ind</span><span class="p">,</span> <span class="n">instances</span><span class="o">=</span><span class="n">predicted_instances</span>
        <span class="p">)</span>

        <span class="n">predicted_frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labeled_frame</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">predicted_frames</span>


<span class="k">def</span> <span class="nf">get_keras_model_path</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="n">Text</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Text</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.json&quot;</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;best_model.h5&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="Predictor"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.Predictor">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Predictor</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base interface class for predictors.&quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">from_trained_models</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">make_pipeline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_provider</span><span class="p">:</span> <span class="n">Provider</span><span class="p">):</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="MockPredictor"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.MockPredictor">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MockPredictor</span><span class="p">(</span><span class="n">Predictor</span><span class="p">):</span>
    <span class="n">labels</span><span class="p">:</span> <span class="n">sleap</span><span class="o">.</span><span class="n">Labels</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_trained_models</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">labels_path</span><span class="p">:</span> <span class="n">Text</span><span class="p">):</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">Labels</span><span class="o">.</span><span class="n">load_file</span><span class="p">(</span><span class="n">labels_path</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_pipeline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_provider</span><span class="p">:</span> <span class="n">Provider</span><span class="p">):</span>

        <span class="n">prediction_video</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Try to match specified video by its full path</span>
        <span class="n">prediction_video_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">data_provider</span><span class="o">.</span><span class="n">video</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">video</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">videos</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">video</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span> <span class="o">==</span> <span class="n">prediction_video_path</span><span class="p">:</span>
                <span class="n">prediction_video</span> <span class="o">=</span> <span class="n">video</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">prediction_video</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Try to match on filename (without path)</span>
            <span class="n">prediction_video_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">data_provider</span><span class="o">.</span><span class="n">video</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">video</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">videos</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">video</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span> <span class="o">==</span> <span class="n">prediction_video_path</span><span class="p">:</span>
                    <span class="n">prediction_video</span> <span class="o">=</span> <span class="n">video</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">prediction_video</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Default to first video in labels file</span>
            <span class="n">prediction_video</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">videos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Get specified frames from labels file (or use None for all frames)</span>
        <span class="n">frame_idx_list</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">data_provider</span><span class="o">.</span><span class="n">example_indices</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">data_provider</span><span class="o">.</span><span class="n">example_indices</span>
            <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>

        <span class="n">frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">video</span><span class="o">=</span><span class="n">prediction_video</span><span class="p">,</span> <span class="n">frame_idx</span><span class="o">=</span><span class="n">frame_idx_list</span><span class="p">)</span>

        <span class="c1"># Run tracker as specified</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracker</span><span class="p">:</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="n">run_tracker</span><span class="p">(</span><span class="n">tracker</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tracker</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="n">frames</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracker</span><span class="o">.</span><span class="n">final_pass</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>

        <span class="c1"># Return frames (there are no &quot;raw&quot; predictions we could return)</span>
        <span class="k">return</span> <span class="n">frames</span></div>


<div class="viewcode-block" id="VisualPredictor"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.VisualPredictor">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">VisualPredictor</span><span class="p">(</span><span class="n">Predictor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Predictor class for generating the visual output of model.&quot;&quot;&quot;</span>

    <span class="n">config</span><span class="p">:</span> <span class="n">TrainingJobConfig</span>
    <span class="n">model</span><span class="p">:</span> <span class="n">Model</span>
    <span class="n">pipeline</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Pipeline</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_trained_models</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">model_path</span><span class="p">:</span> <span class="n">Text</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;VisualPredictor&quot;</span><span class="p">:</span>
        <span class="n">cfg</span> <span class="o">=</span> <span class="n">TrainingJobConfig</span><span class="o">.</span><span class="n">load_json</span><span class="p">(</span><span class="n">model_path</span><span class="p">)</span>
        <span class="n">keras_model_path</span> <span class="o">=</span> <span class="n">get_keras_model_path</span><span class="p">(</span><span class="n">model_path</span><span class="p">)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="o">.</span><span class="n">from_config</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="n">model</span><span class="o">.</span><span class="n">keras_model</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span><span class="n">keras_model_path</span><span class="p">,</span> <span class="nb">compile</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="n">cfg</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">head_specific_output_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Text</span><span class="p">]:</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">confidence_maps_key_name</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
            <span class="n">keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">part_affinity_fields_key_name</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
            <span class="n">keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">keys</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">confidence_maps_key_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Text</span><span class="p">]:</span>
        <span class="n">head_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">heads</span><span class="o">.</span><span class="n">which_oneof_attrib_name</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">head_key</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;multi_instance&quot;</span><span class="p">,</span> <span class="s2">&quot;single_instance&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;predicted_confidence_maps&quot;</span>

        <span class="k">if</span> <span class="n">head_key</span> <span class="o">==</span> <span class="s2">&quot;centroid&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;predicted_centroid_confidence_maps&quot;</span>

        <span class="c1"># todo: centered_instance</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">part_affinity_fields_key_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Text</span><span class="p">]:</span>
        <span class="n">head_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">heads</span><span class="o">.</span><span class="n">which_oneof_attrib_name</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">head_key</span> <span class="o">==</span> <span class="s2">&quot;multi_instance&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;predicted_part_affinity_fields&quot;</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">make_pipeline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">()</span>

        <span class="n">pipeline</span> <span class="o">+=</span> <span class="n">Normalizer</span><span class="o">.</span><span class="n">from_config</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">preprocessing</span><span class="p">)</span>
        <span class="n">pipeline</span> <span class="o">+=</span> <span class="n">Resizer</span><span class="o">.</span><span class="n">from_config</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">preprocessing</span><span class="p">,</span> <span class="n">keep_full_image</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">points_key</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">)</span>

        <span class="n">pipeline</span> <span class="o">+=</span> <span class="n">KerasModelPredictor</span><span class="p">(</span>
            <span class="n">keras_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">keras_model</span><span class="p">,</span>
            <span class="n">model_input_keys</span><span class="o">=</span><span class="s2">&quot;image&quot;</span><span class="p">,</span>
            <span class="n">model_output_keys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">head_specific_output_keys</span><span class="p">(),</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">pipeline</span>

    <span class="k">def</span> <span class="nf">predict_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_provider</span><span class="p">:</span> <span class="n">Provider</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Pass in data provider when mocking one of the models.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_pipeline</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">providers</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_provider</span><span class="p">]</span>

        <span class="c1"># Yield each example from dataset, catching and logging exceptions</span>
        <span class="k">return</span> <span class="n">safely_generate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">make_dataset</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_provider</span><span class="p">:</span> <span class="n">Provider</span><span class="p">):</span>
        <span class="n">generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_generator</span><span class="p">(</span><span class="n">data_provider</span><span class="p">)</span>
        <span class="n">examples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">examples</span></div>


<div class="viewcode-block" id="CentroidCropGroundTruth"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.CentroidCropGroundTruth">[docs]</a><span class="k">class</span> <span class="nc">CentroidCropGroundTruth</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Layer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Keras layer that simulates a centroid cropping model using ground truth.</span>

<span class="sd">    This layer is useful for testing and evaluating centered instance models.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        crop_size: The length of the square box to extract around each centroid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crop_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crop_size</span> <span class="o">=</span> <span class="n">crop_size</span>

<div class="viewcode-block" id="CentroidCropGroundTruth.call"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.CentroidCropGroundTruth.call">[docs]</a>    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">example_gt</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return the ground truth instance crops.</span>

<span class="sd">        Args:</span>
<span class="sd">            example_gt: Dictionary generated from a labels pipeline with the keys:</span>
<span class="sd">                `&quot;image&quot;: (batch_size, height, width, channels)`</span>
<span class="sd">                `&quot;centroids&quot;: (batch_size, n_centroids, 2)`: The input centroids.</span>
<span class="sd">                    Axis 1 is expected to be ragged.</span>
<span class="sd">                These can be generated by the `InstanceCentroidFinder` transformer.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary containing the output of the instance cropping layer with keys:</span>
<span class="sd">            `&quot;crops&quot;: (batch_size, n_centroids, crop_size, crop_size, channels)`</span>
<span class="sd">            `&quot;crop_offsets&quot;: (batch_size, n_centroids, crop_size, crop_size, channels)`</span>
<span class="sd">                These contain the top-left coordinates of each crop in the full images.</span>
<span class="sd">            `&quot;centroids&quot;: (batch_size, n_centroids, 2)`</span>
<span class="sd">            `&quot;centroid_vals&quot;: (batch_size, n_centroids)`</span>

<span class="sd">            Axis 1 of all keys are expected to be ragged.</span>

<span class="sd">            `&quot;centroids&quot;` are from the input example and `&quot;centroid_vals&quot;` will be</span>
<span class="sd">            filled with ones.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Pull out data from example.</span>
        <span class="n">full_imgs</span> <span class="o">=</span> <span class="n">example_gt</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span>
        <span class="n">crop_sample_inds</span> <span class="o">=</span> <span class="n">example_gt</span><span class="p">[</span><span class="s2">&quot;centroids&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value_rowids</span><span class="p">()</span>  <span class="c1"># (n_peaks,)</span>
        <span class="n">n_peaks</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">crop_sample_inds</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># total number of peaks in the batch</span>
        <span class="n">centroid_points</span> <span class="o">=</span> <span class="n">example_gt</span><span class="p">[</span><span class="s2">&quot;centroids&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">flat_values</span>  <span class="c1"># (n_peaks, 2)</span>
        <span class="n">centroid_vals</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">centroid_points</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># (n_peaks,)</span>

        <span class="c1"># Store crop offsets.</span>
        <span class="n">crop_offsets</span> <span class="o">=</span> <span class="n">centroid_points</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crop_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Crop instances around centroids.</span>
        <span class="n">bboxes</span> <span class="o">=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">instance_cropping</span><span class="o">.</span><span class="n">make_centered_bboxes</span><span class="p">(</span>
            <span class="n">centroid_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop_size</span>
        <span class="p">)</span>
        <span class="n">crops</span> <span class="o">=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">peak_finding</span><span class="o">.</span><span class="n">crop_bboxes</span><span class="p">(</span><span class="n">full_imgs</span><span class="p">,</span> <span class="n">bboxes</span><span class="p">,</span> <span class="n">crop_sample_inds</span><span class="p">)</span>

        <span class="c1"># Reshape to (n_peaks, crop_height, crop_width, channels)</span>
        <span class="n">img_channels</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">full_imgs</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">crops</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">crops</span><span class="p">,</span> <span class="p">[</span><span class="n">n_peaks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop_size</span><span class="p">,</span> <span class="n">img_channels</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Group crops by sample.</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">full_imgs</span><span class="p">,</span> <span class="n">out_type</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int64</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">crops</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
            <span class="n">crops</span><span class="p">,</span> <span class="n">crop_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">samples</span>
        <span class="p">)</span>
        <span class="n">crop_offsets</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
            <span class="n">crop_offsets</span><span class="p">,</span> <span class="n">crop_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">samples</span>
        <span class="p">)</span>
        <span class="n">centroid_vals</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
            <span class="n">centroid_vals</span><span class="p">,</span> <span class="n">crop_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">samples</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">crops</span><span class="o">=</span><span class="n">crops</span><span class="p">,</span>
            <span class="n">crop_offsets</span><span class="o">=</span><span class="n">crop_offsets</span><span class="p">,</span>
            <span class="n">centroids</span><span class="o">=</span><span class="n">example_gt</span><span class="p">[</span><span class="s2">&quot;centroids&quot;</span><span class="p">],</span>
            <span class="n">centroid_vals</span><span class="o">=</span><span class="n">centroid_vals</span><span class="p">,</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="FindInstancePeaksGroundTruth"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.FindInstancePeaksGroundTruth">[docs]</a><span class="k">class</span> <span class="nc">FindInstancePeaksGroundTruth</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Layer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Keras layer that simulates a centered instance peaks model.</span>

<span class="sd">    This layer is useful for testing and evaluating centroid models.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

<div class="viewcode-block" id="FindInstancePeaksGroundTruth.call"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.FindInstancePeaksGroundTruth.call">[docs]</a>    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">example_gt</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">crop_output</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return the ground truth instance peaks given a set of crops.</span>

<span class="sd">        Args:</span>
<span class="sd">            example_gt: Dictionary generated from a labels pipeline with the key:</span>
<span class="sd">                `&quot;instances&quot;: (batch_size, n_instances_gt, n_nodes, 2)`</span>
<span class="sd">                    Axes 1 and 2 are expected to be ragged dimensions.</span>
<span class="sd">            crop_output: Dictionary containing the output of the instance cropping layer</span>
<span class="sd">                with keys:</span>
<span class="sd">                `&quot;centroids&quot;: (batch_size, n_centroids, 2)`,</span>
<span class="sd">                `&quot;centroid_vals&quot;: (batch_size, n_centroids)`</span>
<span class="sd">                    Axis 1 of both keys are expected to be ragged.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary with the instance peaks for each frame. The peaks are just the</span>
<span class="sd">            ground truth instances matched to the crop output centroids via greedy</span>
<span class="sd">            matching of the closest node point to each centroid.</span>

<span class="sd">            The output will have keys:</span>
<span class="sd">                `&quot;centroids&quot;: (batch_size, n_centroids, 2)`: The input centroids.</span>
<span class="sd">                `&quot;centroid_vals&quot;: (batch_size, n_centroids)`: The input centroid</span>
<span class="sd">                    confidence values.</span>
<span class="sd">                `&quot;instance_peaks&quot;: (batch_size, n_centroids, n_nodes, 2)`: The matched</span>
<span class="sd">                    instances.</span>
<span class="sd">                `&quot;instance_peak_vals&quot;: (batch_size, n_centroids, n_nodes)`: Peak</span>
<span class="sd">                    confidence values (all 1.0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute pairwise distances between centroids and all instance points within</span>
        <span class="c1"># each sample.</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
            <span class="n">example_gt</span><span class="p">[</span><span class="s2">&quot;instances&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">with_row_splits_dtype</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>  <span class="c1"># (batch_size, 1, n_insts, n_nodes, 2)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">to_tensor</span><span class="p">(</span><span class="n">default_value</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">crop_output</span><span class="p">[</span><span class="s2">&quot;centroids&quot;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span><span class="o">.</span><span class="n">with_row_splits_dtype</span><span class="p">(</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">int64</span>
        <span class="p">)</span>  <span class="c1"># (batch_size, n_centroids, 1, 1, 2)</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>  <span class="c1"># (batch_size, n_centroids, n_insts, n_nodes, 2)</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">dists</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># reduce over xy</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_min</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># reduce over nodes</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">dists</span><span class="o">.</span><span class="n">to_tensor</span><span class="p">(</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># (batch_size, n_centroids, n_insts)</span>

        <span class="c1"># Find nearest GT instance to each centroid.</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># (batch_size, n_centroids)</span>

        <span class="c1"># Argmin will return indices for NaNs as well, so we must filter the matches.</span>
        <span class="n">subs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">tf</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">is_nan</span><span class="p">(</span><span class="n">dists</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">valid_matches</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather_nd</span><span class="p">(</span><span class="n">matches</span><span class="p">,</span> <span class="n">subs</span><span class="p">)</span>
        <span class="n">match_sample_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">subs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Get the matched instances.</span>
        <span class="n">instance_peaks</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather_nd</span><span class="p">(</span>
            <span class="n">example_gt</span><span class="p">[</span><span class="s2">&quot;instances&quot;</span><span class="p">],</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">match_sample_inds</span><span class="p">,</span> <span class="n">valid_matches</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">instance_peaks</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
            <span class="n">instance_peaks</span><span class="p">,</span> <span class="n">match_sample_inds</span>
        <span class="p">)</span>  <span class="c1"># (batch_size, n_centroids, n_nodes, 2)</span>

        <span class="c1"># Set all peak values to 1.</span>
        <span class="n">instance_peak_vals</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">instance_peaks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>  <span class="c1"># (batch_size, n_centroids, n_nodes)</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">centroids</span><span class="o">=</span><span class="n">crop_output</span><span class="p">[</span><span class="s2">&quot;centroids&quot;</span><span class="p">],</span>
            <span class="n">centroid_vals</span><span class="o">=</span><span class="n">crop_output</span><span class="p">[</span><span class="s2">&quot;centroid_vals&quot;</span><span class="p">],</span>
            <span class="n">instance_peaks</span><span class="o">=</span><span class="n">instance_peaks</span><span class="p">,</span>
            <span class="n">instance_peak_vals</span><span class="o">=</span><span class="n">instance_peak_vals</span><span class="p">,</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="InferenceLayer"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.InferenceLayer">[docs]</a><span class="k">class</span> <span class="nc">InferenceLayer</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Layer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base layer for wrapping a Keras model into a layer with preprocessing.</span>

<span class="sd">    This layer is useful for wrapping input preprocessing operations that would</span>
<span class="sd">    otherwise be handled by a separate pipeline.</span>

<span class="sd">    This layer expects the same input as the model (rank-4 image) and automatically</span>
<span class="sd">    converts the input to a float if it is in integer form. This can help improve</span>
<span class="sd">    performance by enabling inference directly on `uint8` inputs.</span>

<span class="sd">    The `call()` method can be overloaded to create custom inference routines that</span>
<span class="sd">    take advantage of the `preprocess()` method.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        keras_model: A `tf.keras.Model` that will be called on the input to this layer.</span>
<span class="sd">        input_scale: If not 1.0, input image will be resized by this factor.</span>
<span class="sd">        pad_to_stride: If not 1, input image will be paded to ensure that it is</span>
<span class="sd">            divisible by this value (after scaling).</span>
<span class="sd">        ensure_grayscale: If `True`, converts inputs to grayscale if not already. If</span>
<span class="sd">            `False`, converts inputs to RGB if not already. If `None` (default), infer</span>
<span class="sd">            from the shape of the input layer of the model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keras_model</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">,</span>
        <span class="n">input_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">pad_to_stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">ensure_grayscale</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keras_model</span> <span class="o">=</span> <span class="n">keras_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_scale</span> <span class="o">=</span> <span class="n">input_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pad_to_stride</span> <span class="o">=</span> <span class="n">pad_to_stride</span>
        <span class="k">if</span> <span class="n">ensure_grayscale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ensure_grayscale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keras_model</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ensure_grayscale</span> <span class="o">=</span> <span class="n">ensure_grayscale</span>

<div class="viewcode-block" id="InferenceLayer.preprocess"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.InferenceLayer.preprocess">[docs]</a>    <span class="k">def</span> <span class="nf">preprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imgs</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Apply all preprocessing operations configured for this layer.</span>

<span class="sd">        Args:</span>
<span class="sd">            imgs: A batch of images as a tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The input tensor after applying preprocessing operations. The tensor will</span>
<span class="sd">            always be a `tf.float32`, which will be adjusted to the range `[0, 1]` if it</span>
<span class="sd">            was previously an integer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensure_grayscale</span><span class="p">:</span>
            <span class="n">imgs</span> <span class="o">=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">normalization</span><span class="o">.</span><span class="n">ensure_grayscale</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">imgs</span> <span class="o">=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">normalization</span><span class="o">.</span><span class="n">ensure_rgb</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>

        <span class="n">imgs</span> <span class="o">=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">normalization</span><span class="o">.</span><span class="n">ensure_float</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_scale</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">imgs</span> <span class="o">=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">resizing</span><span class="o">.</span><span class="n">resize_image</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_scale</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_to_stride</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">imgs</span> <span class="o">=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">resizing</span><span class="o">.</span><span class="n">pad_to_stride</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_to_stride</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">imgs</span></div>

<div class="viewcode-block" id="InferenceLayer.call"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.InferenceLayer.call">[docs]</a>    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Call the model with preprocessed data.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: Inputs to the model.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Output of the model after being called with preprocessing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">keras_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span><span class="p">(</span><span class="n">data</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="get_model_output_stride"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.get_model_output_stride">[docs]</a><span class="k">def</span> <span class="nf">get_model_output_stride</span><span class="p">(</span>
    <span class="n">model</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">,</span> <span class="n">input_ind</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">output_ind</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns the stride (1/scale) of the model outputs relative to the input.</span>

<span class="sd">    Args:</span>
<span class="sd">        model: A `tf.keras.Model`.</span>
<span class="sd">        input_ind: The index of the input to use as reference. Defaults to 0, indicating</span>
<span class="sd">            the first input for multi-output models.</span>
<span class="sd">        output_ind: The index of the output to compute the stride for. Defaults to -1,</span>
<span class="sd">            indicating the last output for multi-output models.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The output stride of the model computed as the integer ratio of the input&#39;s</span>
<span class="sd">        height relative to the output&#39;s height, e.g., for a single input/output model:</span>

<span class="sd">            `model.input.shape[1] // model.output.shape[1]`</span>

<span class="sd">        Raises a warning if the shapes do not divide evenly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">size_in</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">input_ind</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">size_out</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">output_ind</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">size_in</span> <span class="o">%</span> <span class="n">size_out</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Model input of shape </span><span class="si">{</span><span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">input_ind</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> does not divide &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;evenly with output of shape </span><span class="si">{</span><span class="n">model</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">output_ind</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">size_in</span> <span class="o">//</span> <span class="n">size_out</span></div>


<div class="viewcode-block" id="CentroidCrop"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.CentroidCrop">[docs]</a><span class="k">class</span> <span class="nc">CentroidCrop</span><span class="p">(</span><span class="n">InferenceLayer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Inference layer for applying centroid crop-based models.</span>

<span class="sd">    This layer encapsulates all of the inference operations requires for generating</span>
<span class="sd">    predictions from a centroid confidence map model. This includes preprocessing,</span>
<span class="sd">    model forward pass, peak finding, coordinate adjustment and cropping.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        keras_model: A `tf.keras.Model` that accepts rank-4 images as input and predicts</span>
<span class="sd">            rank-4 confidence maps as output. This should be a model that is trained on</span>
<span class="sd">            centroid/anchor confidence maps.</span>
<span class="sd">        crop_size: Integer scalar specifying the height/width of the centered crops.</span>
<span class="sd">        input_scale: Float indicating if the images should be resized before being</span>
<span class="sd">            passed to the model.</span>
<span class="sd">        pad_to_stride: If not 1, input image will be paded to ensure that it is</span>
<span class="sd">            divisible by this value (after scaling). This should be set to the max</span>
<span class="sd">            stride of the model.</span>
<span class="sd">        output_stride: Output stride of the model, denoting the scale of the output</span>
<span class="sd">            confidence maps relative to the images (after input scaling). This is used</span>
<span class="sd">            for adjusting the peak coordinates to the image grid. This will be inferred</span>
<span class="sd">            from the model shapes if not provided.</span>
<span class="sd">        peak_threshold: Minimum confidence map value to consider a global peak as valid.</span>
<span class="sd">        refinement: If `None`, returns the grid-aligned peaks with no refinement. If</span>
<span class="sd">            `&quot;integral&quot;`, peaks will be refined with integral regression. If `&quot;local&quot;`,</span>
<span class="sd">            peaks will be refined with quarter pixel local gradient offset.</span>
<span class="sd">        integral_patch_size: Size of patches to crop around each rough peak for integral</span>
<span class="sd">            refinement as an integer scalar.</span>
<span class="sd">        return_confmaps: If `True`, the confidence maps will be returned together with</span>
<span class="sd">            the predicted peaks. This will result in slower inference times since the</span>
<span class="sd">            data must be copied off of the GPU, but is useful for visualizing the raw</span>
<span class="sd">            output of the model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keras_model</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">,</span>
        <span class="n">crop_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">input_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">pad_to_stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">output_stride</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">peak_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">refinement</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;local&quot;</span><span class="p">,</span>
        <span class="n">integral_patch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">return_confmaps</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">keras_model</span><span class="o">=</span><span class="n">keras_model</span><span class="p">,</span>
            <span class="n">input_scale</span><span class="o">=</span><span class="n">input_scale</span><span class="p">,</span>
            <span class="n">pad_to_stride</span><span class="o">=</span><span class="n">pad_to_stride</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">crop_size</span> <span class="o">=</span> <span class="n">crop_size</span>

        <span class="k">if</span> <span class="n">output_stride</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Attempt to automatically infer the output stride.</span>
            <span class="n">output_stride</span> <span class="o">=</span> <span class="n">get_model_output_stride</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keras_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_stride</span> <span class="o">=</span> <span class="n">output_stride</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">peak_threshold</span> <span class="o">=</span> <span class="n">peak_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refinement</span> <span class="o">=</span> <span class="n">refinement</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integral_patch_size</span> <span class="o">=</span> <span class="n">integral_patch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_confmaps</span> <span class="o">=</span> <span class="n">return_confmaps</span>

<div class="viewcode-block" id="CentroidCrop.call"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.CentroidCrop.call">[docs]</a>    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Predict centroid confidence maps and crop around peaks.</span>

<span class="sd">        This layer can be chained with a `FindInstancePeaks` layer to create a top-down</span>
<span class="sd">        inference function from full images.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs: Full frame images as a `tf.Tensor` of shape</span>
<span class="sd">                `(samples, height, width, channels)` or a dictionary with key:</span>
<span class="sd">                `&quot;image&quot;`: Full frame images in the same format as above.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary of outputs grouped by sample with keys:</span>

<span class="sd">            `&quot;crops&quot;`: Cropped images of shape</span>
<span class="sd">                `(samples, ?, crop_size, crop_size, channels)`.</span>
<span class="sd">            `&quot;crop_offsets&quot;`: Coordinates of the top-left of the crops as `(x, y)`</span>
<span class="sd">                offsets of shape `(samples, ?, 2)` for adjusting the predicted peak</span>
<span class="sd">                coordinates.</span>
<span class="sd">            `&quot;centroids&quot;`: The predicted centroids of shape `(samples, ?, 2)`.</span>
<span class="sd">            `&quot;centroid_vals&quot;: The centroid confidence values of shape `(samples, ?)`.</span>

<span class="sd">            If the `return_confmaps` attribute is set to `True`, the output will also</span>
<span class="sd">            contain a key named `&quot;centroid_confmaps&quot;` containing a `tf.RaggedTensor` of</span>
<span class="sd">            shape `(samples, ?, output_height, output_width, 1)` containing the</span>
<span class="sd">            confidence maps predicted by the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># Pull out image from example dictionary.</span>
            <span class="n">imgs</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assume inputs are image tensors.</span>
            <span class="n">imgs</span> <span class="o">=</span> <span class="n">inputs</span>

        <span class="c1"># Store full images for cropping.</span>
        <span class="n">full_imgs</span> <span class="o">=</span> <span class="n">imgs</span>

        <span class="c1"># Preprocess inputs (scaling, padding, colorspace, int to float).</span>
        <span class="n">imgs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>

        <span class="c1"># Predict confidence maps.</span>
        <span class="n">cms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keras_model</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cms</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># Take the last output if multi-output model.</span>
            <span class="c1"># TODO: Specify output index explicitly.</span>
            <span class="n">cms</span> <span class="o">=</span> <span class="n">cms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Find centroids peaks.</span>
        <span class="p">(</span>
            <span class="n">centroid_points</span><span class="p">,</span>
            <span class="n">centroid_vals</span><span class="p">,</span>
            <span class="n">crop_sample_inds</span><span class="p">,</span>
            <span class="n">_</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">peak_finding</span><span class="o">.</span><span class="n">find_local_peaks</span><span class="p">(</span>
            <span class="n">cms</span><span class="p">,</span>
            <span class="n">threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">peak_threshold</span><span class="p">,</span>
            <span class="n">refinement</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">refinement</span><span class="p">,</span>
            <span class="n">integral_patch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">integral_patch_size</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Adjust for stride and scale.</span>
        <span class="n">centroid_points</span> <span class="o">=</span> <span class="n">centroid_points</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_stride</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_scale</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="c1"># Note: We add 0.5 here to offset TensorFlow&#39;s weird image resizing. This</span>
            <span class="c1"># may not always(?) be the most correct approach.</span>
            <span class="c1"># See: https://github.com/tensorflow/tensorflow/issues/6720</span>
            <span class="n">centroid_points</span> <span class="o">=</span> <span class="p">(</span><span class="n">centroid_points</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_scale</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span>

        <span class="c1"># Store crop offsets.</span>
        <span class="n">crop_offsets</span> <span class="o">=</span> <span class="n">centroid_points</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crop_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">n_peaks</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">centroid_points</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n_peaks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Crop instances around centroids.</span>
            <span class="n">bboxes</span> <span class="o">=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">instance_cropping</span><span class="o">.</span><span class="n">make_centered_bboxes</span><span class="p">(</span>
                <span class="n">centroid_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop_size</span>
            <span class="p">)</span>
            <span class="n">crops</span> <span class="o">=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">peak_finding</span><span class="o">.</span><span class="n">crop_bboxes</span><span class="p">(</span>
                <span class="n">full_imgs</span><span class="p">,</span> <span class="n">bboxes</span><span class="p">,</span> <span class="n">crop_sample_inds</span>
            <span class="p">)</span>

            <span class="c1"># Reshape to (n_peaks, crop_height, crop_width, channels)</span>
            <span class="n">crops</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">crops</span><span class="p">,</span> <span class="p">[</span><span class="n">n_peaks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop_size</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">full_imgs</span><span class="p">)[</span><span class="mi">3</span><span class="p">]]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># No peaks found, so just create a placeholder stack.</span>
            <span class="n">crops</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">[</span><span class="n">n_peaks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop_size</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">full_imgs</span><span class="p">)[</span><span class="mi">3</span><span class="p">]],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">full_imgs</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Group crops by sample (samples, ?, ...).</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">imgs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
            <span class="n">centroid_points</span><span class="p">,</span> <span class="n">crop_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">samples</span>
        <span class="p">)</span>
        <span class="n">crops</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
            <span class="n">crops</span><span class="p">,</span> <span class="n">crop_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">samples</span>
        <span class="p">)</span>
        <span class="n">crop_offsets</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
            <span class="n">crop_offsets</span><span class="p">,</span> <span class="n">crop_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">samples</span>
        <span class="p">)</span>
        <span class="n">centroid_vals</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
            <span class="n">centroid_vals</span><span class="p">,</span> <span class="n">crop_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">samples</span>
        <span class="p">)</span>

        <span class="n">outputs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">centroids</span><span class="o">=</span><span class="n">centroids</span><span class="p">,</span>
            <span class="n">centroid_vals</span><span class="o">=</span><span class="n">centroid_vals</span><span class="p">,</span>
            <span class="n">crops</span><span class="o">=</span><span class="n">crops</span><span class="p">,</span>
            <span class="n">crop_offsets</span><span class="o">=</span><span class="n">crop_offsets</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_confmaps</span><span class="p">:</span>
            <span class="c1"># Return confidence maps with outputs.</span>
            <span class="n">cms</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
                <span class="n">cms</span><span class="p">,</span> <span class="n">crop_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">samples</span>
            <span class="p">)</span>
            <span class="n">outputs</span><span class="p">[</span><span class="s2">&quot;centroid_confmaps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cms</span>
        <span class="k">return</span> <span class="n">outputs</span></div></div>


<div class="viewcode-block" id="FindInstancePeaks"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.FindInstancePeaks">[docs]</a><span class="k">class</span> <span class="nc">FindInstancePeaks</span><span class="p">(</span><span class="n">InferenceLayer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Keras layer that predicts instance peaks from images using a trained model.</span>

<span class="sd">    This layer encapsulates all of the inference operations required for generating</span>
<span class="sd">    predictions from a centered instance confidence map model. This includes</span>
<span class="sd">    preprocessing, model forward pass, peak finding and coordinate adjustment.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        keras_model: A `tf.keras.Model` that accepts rank-4 images as input and predicts</span>
<span class="sd">            rank-4 confidence maps as output. This should be a model that is trained on</span>
<span class="sd">            centered instance confidence maps.</span>
<span class="sd">        input_scale: Float indicating if the images should be resized before being</span>
<span class="sd">            passed to the model.</span>
<span class="sd">        output_stride: Output stride of the model, denoting the scale of the output</span>
<span class="sd">            confidence maps relative to the images (after input scaling). This is used</span>
<span class="sd">            for adjusting the peak coordinates to the image grid. This will be inferred</span>
<span class="sd">            from the model shapes if not provided.</span>
<span class="sd">        peak_threshold: Minimum confidence map value to consider a global peak as valid.</span>
<span class="sd">        refinement: If `None`, returns the grid-aligned peaks with no refinement. If</span>
<span class="sd">            `&quot;integral&quot;`, peaks will be refined with integral regression. If `&quot;local&quot;`,</span>
<span class="sd">            peaks will be refined with quarter pixel local gradient offset.</span>
<span class="sd">        integral_patch_size: Size of patches to crop around each rough peak for integral</span>
<span class="sd">            refinement as an integer scalar.</span>
<span class="sd">        return_confmaps: If `True`, the confidence maps will be returned together with</span>
<span class="sd">            the predicted peaks. This will result in slower inference times since the</span>
<span class="sd">            data must be copied off of the GPU, but is useful for visualizing the raw</span>
<span class="sd">            output of the model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keras_model</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">,</span>
        <span class="n">input_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">output_stride</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">peak_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">refinement</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;local&quot;</span><span class="p">,</span>
        <span class="n">integral_patch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">return_confmaps</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">keras_model</span><span class="o">=</span><span class="n">keras_model</span><span class="p">,</span> <span class="n">input_scale</span><span class="o">=</span><span class="n">input_scale</span><span class="p">,</span> <span class="n">pad_to_stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">output_stride</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Attempt to automatically infer the output stride.</span>
            <span class="n">output_stride</span> <span class="o">=</span> <span class="n">get_model_output_stride</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keras_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_stride</span> <span class="o">=</span> <span class="n">output_stride</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">peak_threshold</span> <span class="o">=</span> <span class="n">peak_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refinement</span> <span class="o">=</span> <span class="n">refinement</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integral_patch_size</span> <span class="o">=</span> <span class="n">integral_patch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_confmaps</span> <span class="o">=</span> <span class="n">return_confmaps</span>

<div class="viewcode-block" id="FindInstancePeaks.call"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.FindInstancePeaks.call">[docs]</a>    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Predict confidence maps and infer peak coordinates.</span>

<span class="sd">        This layer can be chained with a `CentroidCrop` layer to create a top-down</span>
<span class="sd">        inference function from full images.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs: Instance-centered images as a `tf.Tensor` of shape</span>
<span class="sd">                `(samples, height, width, channels)` or `tf.RaggedTensor` of shape</span>
<span class="sd">                `(samples, ?, height, width, channels)` where images are grouped by</span>
<span class="sd">                sample and may contain a variable number of crops, or a dictionary with</span>
<span class="sd">                keys:</span>
<span class="sd">                `&quot;crops&quot;`: Cropped images in either format above.</span>
<span class="sd">                `&quot;crop_offsets&quot;`: (Optional) Coordinates of the top-left of the crops as</span>
<span class="sd">                    `(x, y)` offsets of shape `(samples, ?, 2)` for adjusting the</span>
<span class="sd">                    predicted peak coordinates. No adjustment is performed if not</span>
<span class="sd">                    provided.</span>
<span class="sd">                `&quot;centroids&quot;`: (Optional) If provided, will be passed through to the</span>
<span class="sd">                    output.</span>
<span class="sd">                `&quot;centroid_vals&quot;`: (Optional) If provided, will be passed through to the</span>
<span class="sd">                    output.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary of outputs with keys:</span>

<span class="sd">            `&quot;instance_peaks&quot;`: The predicted peaks for each instance in the batch as a</span>
<span class="sd">                `tf.RaggedTensor` of shape `(samples, ?, nodes, 2)`.</span>
<span class="sd">            `&quot;instance_peak_vals&quot;`: The value of the confidence maps at the predicted</span>
<span class="sd">                peaks for each instance in the batch as a `tf.RaggedTensor` of shape</span>
<span class="sd">                `(samples, ?, nodes)`.</span>

<span class="sd">            If provided (e.g., from an input `CentroidCrop` layer), the centroids that</span>
<span class="sd">            generated the crops will also be included in the keys `&quot;centroids&quot;` and</span>
<span class="sd">            `&quot;centroid_vals&quot;`.</span>

<span class="sd">            If the `return_confmaps` attribute is set to `True`, the output will also</span>
<span class="sd">            contain a key named `&quot;instance_confmaps&quot;` containing a `tf.RaggedTensor` of</span>
<span class="sd">            shape `(samples, ?, output_height, output_width, nodes)` containing the</span>
<span class="sd">            confidence maps predicted by the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">crops</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;crops&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Tensor input provided. We&#39;ll infer the extra fields in the expected input</span>
            <span class="c1"># dictionary.</span>
            <span class="n">crops</span> <span class="o">=</span> <span class="n">inputs</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crops</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">):</span>
            <span class="n">crops</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;crops&quot;</span><span class="p">]</span>  <span class="c1"># (samples, ?, height, width, channels)</span>

            <span class="c1"># Flatten crops into (n_peaks, height, width, channels)</span>
            <span class="n">crop_sample_inds</span> <span class="o">=</span> <span class="n">crops</span><span class="o">.</span><span class="n">value_rowids</span><span class="p">()</span>  <span class="c1"># (n_peaks,)</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">crops</span><span class="o">.</span><span class="n">nrows</span><span class="p">()</span>
            <span class="n">crops</span> <span class="o">=</span> <span class="n">crops</span><span class="o">.</span><span class="n">merge_dims</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;crop_sample_inds&quot;</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
                <span class="c1"># Crops provided as a regular tensor, use the metadata are in the input.</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;samples&quot;</span><span class="p">]</span>
                <span class="n">crop_sample_inds</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;crop_sample_inds&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Assuming crops is (samples, height, width, channels).</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">crops</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">crop_sample_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># Preprocess inputs (scaling, padding, colorspace, int to float).</span>
        <span class="n">crops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span><span class="p">(</span><span class="n">crops</span><span class="p">)</span>

        <span class="c1"># Confidence maps estimation.</span>
        <span class="n">cms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keras_model</span><span class="p">(</span><span class="n">crops</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cms</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># Take the last output if multi-output model.</span>
            <span class="c1"># TODO: Specify output index explicitly.</span>
            <span class="n">cms</span> <span class="o">=</span> <span class="n">cms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Find peaks.</span>
        <span class="n">peak_points</span><span class="p">,</span> <span class="n">peak_vals</span> <span class="o">=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">peak_finding</span><span class="o">.</span><span class="n">find_global_peaks</span><span class="p">(</span>
            <span class="n">cms</span><span class="p">,</span>
            <span class="n">threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">peak_threshold</span><span class="p">,</span>
            <span class="n">refinement</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">refinement</span><span class="p">,</span>
            <span class="n">integral_patch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">integral_patch_size</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Adjust for stride and scale.</span>
        <span class="n">peak_points</span> <span class="o">=</span> <span class="n">peak_points</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_stride</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_scale</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="c1"># Note: We add 0.5 here to offset TensorFlow&#39;s weird image resizing. This</span>
            <span class="c1"># may not always(?) be the most correct approach.</span>
            <span class="c1"># See: https://github.com/tensorflow/tensorflow/issues/6720</span>
            <span class="n">peak_points</span> <span class="o">=</span> <span class="p">(</span><span class="n">peak_points</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_scale</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span>

        <span class="c1"># Adjust for crop offsets if provided.</span>
        <span class="k">if</span> <span class="s2">&quot;crop_offsets&quot;</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="c1"># Flatten (samples, ?, 2) -&gt; (n_peaks, 2).</span>
            <span class="n">crop_offsets</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;crop_offsets&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">merge_dims</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">peak_points</span> <span class="o">=</span> <span class="n">peak_points</span> <span class="o">+</span> <span class="n">tf</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">crop_offsets</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Group peaks by sample (samples, ?, nodes, 2).</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
            <span class="n">peak_points</span><span class="p">,</span> <span class="n">crop_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">samples</span>
        <span class="p">)</span>
        <span class="n">peak_vals</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
            <span class="n">peak_vals</span><span class="p">,</span> <span class="n">crop_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">samples</span>
        <span class="p">)</span>

        <span class="c1"># Build outputs.</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;instance_peaks&quot;</span><span class="p">:</span> <span class="n">peaks</span><span class="p">,</span> <span class="s2">&quot;instance_peak_vals&quot;</span><span class="p">:</span> <span class="n">peak_vals</span><span class="p">}</span>
        <span class="k">if</span> <span class="s2">&quot;centroids&quot;</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="n">outputs</span><span class="p">[</span><span class="s2">&quot;centroids&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;centroids&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;centroids&quot;</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="n">outputs</span><span class="p">[</span><span class="s2">&quot;centroid_vals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="s2">&quot;centroid_vals&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_confmaps</span><span class="p">:</span>
            <span class="n">cms</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
                <span class="n">cms</span><span class="p">,</span> <span class="n">crop_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">samples</span>
            <span class="p">)</span>
            <span class="n">outputs</span><span class="p">[</span><span class="s2">&quot;instance_confmaps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cms</span>
        <span class="k">return</span> <span class="n">outputs</span></div></div>


<div class="viewcode-block" id="InferenceModel"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.InferenceModel">[docs]</a><span class="k">class</span> <span class="nc">InferenceModel</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;SLEAP inference model base class.</span>

<span class="sd">    This class wraps the `tf.keras.Model` class to provide SLEAP-specific inference</span>
<span class="sd">    utilities such as handling different input data types, preprocessing and variable</span>
<span class="sd">    output shapes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="InferenceModel.predict"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.InferenceModel.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
            <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
            <span class="n">Pipeline</span><span class="p">,</span>
            <span class="n">sleap</span><span class="o">.</span><span class="n">Video</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="n">numpy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;Predict instances in the data.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: Input data in any form. Possible types:</span>
<span class="sd">                - `np.ndarray`, `tf.Tensor`: Images of shape</span>
<span class="sd">                    `(samples, height, width, channels)`</span>
<span class="sd">                - `dict` with key `&quot;image&quot;` as a tensor</span>
<span class="sd">                - `tf.data.Dataset` that generates examples in one of the above formats.</span>
<span class="sd">                - `sleap.Pipeline` that generates examples in one of the above formats.</span>
<span class="sd">                - `sleap.Video` which will be converted into a pipeline that generates</span>
<span class="sd">                    batches of `batch_size` frames.</span>
<span class="sd">            numpy: If `True` (default), returned values will be converted to</span>
<span class="sd">                `np.ndarray`s or Python primitives if scalars.</span>
<span class="sd">            batch_size: Batch size to use for inference. No effect if using a dataset or</span>
<span class="sd">                pipeline as input since those are expected to generate batches.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The model outputs as a dictionary of (potentially ragged) tensors or numpy</span>
<span class="sd">            arrays if `numpy` is `True`.</span>

<span class="sd">            If `numpy` is `False`, values of the dictionary may be `tf.RaggedTensor`s</span>
<span class="sd">            with the same length for axis 0 (samples), but variable length axis 1</span>
<span class="sd">            (instances).</span>

<span class="sd">            If `numpy` is `True` and the output contained ragged tensors, they will be</span>
<span class="sd">            NaN-padded to the bounding shape and an additional key `&quot;n_valid&quot;` will be</span>
<span class="sd">            included to indicate the number of valid elements (before padding) in axis</span>
<span class="sd">            1 of the tensors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">sleap</span><span class="o">.</span><span class="n">Video</span><span class="p">,</span> <span class="n">sleap</span><span class="o">.</span><span class="n">Labels</span><span class="p">)):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to_pipeline</span><span class="p">(</span><span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Pipeline</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">make_dataset</span><span class="p">()</span>

        <span class="n">outs</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">numpy</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">outs</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="p">):</span>
                    <span class="n">outs</span><span class="p">[</span><span class="s2">&quot;n_valid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">row_lengths</span><span class="p">()</span>
                    <span class="k">break</span>
            <span class="n">outs</span> <span class="o">=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">unrag_example</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="n">numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">outs</span></div></div>


<div class="viewcode-block" id="TopDownModel"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.TopDownModel">[docs]</a><span class="k">class</span> <span class="nc">TopDownModel</span><span class="p">(</span><span class="n">InferenceModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Top-down instance prediction model.</span>

<span class="sd">    This model encapsulates the top-down approach where instances are first detected by</span>
<span class="sd">    local peak detection of an anchor point and then cropped. These instance-centered</span>
<span class="sd">    crops are then passed to an instance peak detector which is trained to detect all</span>
<span class="sd">    remaining body parts for the instance that is centered within the crop.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        centroid_crop: A centroid cropping layer. This can be either `CentroidCrop` or</span>
<span class="sd">            `CentroidCropGroundTruth`. This layer takes the full image as input and</span>
<span class="sd">            outputs a set of centroids and cropped boxes.</span>
<span class="sd">        instance_peaks: A instance peak detection layer. This can be either</span>
<span class="sd">            `FindInstancePeaks` or `FindInstancePeaksGroundTruth`. This layer takes as</span>
<span class="sd">            input the output of the centroid cropper and outputs the detected peaks for</span>
<span class="sd">            the instances within each crop.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">centroid_crop</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">CentroidCrop</span><span class="p">,</span> <span class="n">CentroidCropGroundTruth</span><span class="p">],</span>
        <span class="n">instance_peaks</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">FindInstancePeaks</span><span class="p">,</span> <span class="n">FindInstancePeaksGroundTruth</span><span class="p">],</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centroid_crop</span> <span class="o">=</span> <span class="n">centroid_crop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instance_peaks</span> <span class="o">=</span> <span class="n">instance_peaks</span>

<div class="viewcode-block" id="TopDownModel.call"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.TopDownModel.call">[docs]</a>    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">example</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Predict instances for one batch of images.</span>

<span class="sd">        Args:</span>
<span class="sd">            example: This may be either a single batch of images as a 4-D tensor of</span>
<span class="sd">                shape `(batch_size, height, width, channels)`, or a dictionary</span>
<span class="sd">                containing the image batch in the `&quot;images&quot;` key. If using a ground</span>
<span class="sd">                truth model for either centroid cropping or instance peaks, the full</span>
<span class="sd">                example from a `Pipeline` is required for providing the metadata.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The predicted instances as a dictionary of tensors with keys:</span>

<span class="sd">            `&quot;centroids&quot;: (batch_size, n_instances, 2)`: Instance centroids.</span>
<span class="sd">            `&quot;centroid_vals&quot;: (batch_size, n_instances)`: Instance centroid confidence</span>
<span class="sd">                values.</span>
<span class="sd">            `&quot;instance_peaks&quot;: (batch_size, n_instances, n_nodes, 2)`: Instance skeleton</span>
<span class="sd">                points.</span>
<span class="sd">            `&quot;instance_peak_vals&quot;: (batch_size, n_instances, n_nodes)`: Confidence</span>
<span class="sd">                values for the instance skeleton points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="n">example</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">example</span><span class="p">)</span>

        <span class="n">crop_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_crop</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance_peaks</span><span class="p">,</span> <span class="n">FindInstancePeaksGroundTruth</span><span class="p">):</span>
            <span class="n">peaks_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance_peaks</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="n">crop_output</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">peaks_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance_peaks</span><span class="p">(</span><span class="n">crop_output</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">peaks_output</span></div></div>


<div class="viewcode-block" id="TopdownPredictor"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.TopdownPredictor">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">TopdownPredictor</span><span class="p">(</span><span class="n">Predictor</span><span class="p">):</span>
    <span class="n">centroid_config</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TrainingJobConfig</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">centroid_model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Model</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">confmap_config</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TrainingJobConfig</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">confmap_model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Model</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">topdown_model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TopDownModel</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">pipeline</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Pipeline</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">tracker</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tracker</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">peak_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span>
    <span class="n">integral_refinement</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">integral_patch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="k">def</span> <span class="nf">_initialize_topdown_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build the `TopDownModel` for this class from the config/models available.&quot;&quot;&quot;</span>
        <span class="n">use_gt_centroid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_config</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">use_gt_confmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">confmap_config</span> <span class="ow">is</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">use_gt_centroid</span><span class="p">:</span>
            <span class="n">centroid_crop_layer</span> <span class="o">=</span> <span class="n">CentroidCropGroundTruth</span><span class="p">(</span>
                <span class="n">crop_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">confmap_config</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">instance_cropping</span><span class="o">.</span><span class="n">crop_size</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_gt_confmap</span><span class="p">:</span>
                <span class="n">crop_size</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">crop_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">confmap_config</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">instance_cropping</span><span class="o">.</span><span class="n">crop_size</span>
            <span class="n">centroid_crop_layer</span> <span class="o">=</span> <span class="n">CentroidCrop</span><span class="p">(</span>
                <span class="n">keras_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">centroid_model</span><span class="o">.</span><span class="n">keras_model</span><span class="p">,</span>
                <span class="n">crop_size</span><span class="o">=</span><span class="n">crop_size</span><span class="p">,</span>
                <span class="n">input_scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">centroid_config</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">input_scaling</span><span class="p">,</span>
                <span class="n">pad_to_stride</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">centroid_config</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">pad_to_stride</span><span class="p">,</span>
                <span class="n">output_stride</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">centroid_config</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">heads</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">output_stride</span><span class="p">,</span>
                <span class="n">peak_threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">peak_threshold</span><span class="p">,</span>
                <span class="n">refinement</span><span class="o">=</span><span class="s2">&quot;integral&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">integral_refinement</span> <span class="k">else</span> <span class="s2">&quot;local&quot;</span><span class="p">,</span>
                <span class="n">integral_patch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">integral_patch_size</span><span class="p">,</span>
                <span class="n">return_confmaps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">use_gt_confmap</span><span class="p">:</span>
            <span class="n">instance_peaks_layer</span> <span class="o">=</span> <span class="n">FindInstancePeaksGroundTruth</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">instance_peaks_layer</span> <span class="o">=</span> <span class="n">FindInstancePeaks</span><span class="p">(</span>
                <span class="n">keras_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">confmap_model</span><span class="o">.</span><span class="n">keras_model</span><span class="p">,</span>
                <span class="n">input_scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">confmap_config</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">input_scaling</span><span class="p">,</span>
                <span class="n">peak_threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">peak_threshold</span><span class="p">,</span>
                <span class="n">output_stride</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">confmap_config</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">heads</span><span class="o">.</span><span class="n">centered_instance</span><span class="o">.</span><span class="n">output_stride</span><span class="p">,</span>
                <span class="n">refinement</span><span class="o">=</span><span class="s2">&quot;integral&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">integral_refinement</span> <span class="k">else</span> <span class="s2">&quot;local&quot;</span><span class="p">,</span>
                <span class="n">integral_patch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">integral_patch_size</span><span class="p">,</span>
                <span class="n">return_confmaps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">topdown_model</span> <span class="o">=</span> <span class="n">TopDownModel</span><span class="p">(</span>
            <span class="n">centroid_crop</span><span class="o">=</span><span class="n">centroid_crop_layer</span><span class="p">,</span> <span class="n">instance_peaks</span><span class="o">=</span><span class="n">instance_peaks_layer</span>
        <span class="p">)</span>

<div class="viewcode-block" id="TopdownPredictor.from_trained_models"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.TopdownPredictor.from_trained_models">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_trained_models</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">centroid_model_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Text</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">confmap_model_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Text</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">peak_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">integral_refinement</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">integral_patch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;TopdownPredictor&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create predictor from saved models.</span>

<span class="sd">        Args:</span>
<span class="sd">            centroid_model_path: Path to centroid model folder.</span>
<span class="sd">            confmap_model_path: Path to topdown confidence map model folder.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An instance of TopdownPredictor with the loaded models.</span>

<span class="sd">            One of the two models can be left as None to perform inference with ground</span>
<span class="sd">            truth data. This will only work with LabelsReader as the provider.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">centroid_model_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">confmap_model_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Either the centroid or topdown confidence map model must be provided.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">centroid_model_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Load centroid model.</span>
            <span class="n">centroid_config</span> <span class="o">=</span> <span class="n">TrainingJobConfig</span><span class="o">.</span><span class="n">load_json</span><span class="p">(</span><span class="n">centroid_model_path</span><span class="p">)</span>
            <span class="n">centroid_keras_model_path</span> <span class="o">=</span> <span class="n">get_keras_model_path</span><span class="p">(</span><span class="n">centroid_model_path</span><span class="p">)</span>
            <span class="n">centroid_model</span> <span class="o">=</span> <span class="n">Model</span><span class="o">.</span><span class="n">from_config</span><span class="p">(</span><span class="n">centroid_config</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
            <span class="n">centroid_model</span><span class="o">.</span><span class="n">keras_model</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span>
                <span class="n">centroid_keras_model_path</span><span class="p">,</span> <span class="nb">compile</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">centroid_config</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">centroid_model</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">confmap_model_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Load confmap model.</span>
            <span class="n">confmap_config</span> <span class="o">=</span> <span class="n">TrainingJobConfig</span><span class="o">.</span><span class="n">load_json</span><span class="p">(</span><span class="n">confmap_model_path</span><span class="p">)</span>
            <span class="n">confmap_keras_model_path</span> <span class="o">=</span> <span class="n">get_keras_model_path</span><span class="p">(</span><span class="n">confmap_model_path</span><span class="p">)</span>
            <span class="n">confmap_model</span> <span class="o">=</span> <span class="n">Model</span><span class="o">.</span><span class="n">from_config</span><span class="p">(</span><span class="n">confmap_config</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
            <span class="n">confmap_model</span><span class="o">.</span><span class="n">keras_model</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span>
                <span class="n">confmap_keras_model_path</span><span class="p">,</span> <span class="nb">compile</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">confmap_config</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">confmap_model</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">centroid_config</span><span class="o">=</span><span class="n">centroid_config</span><span class="p">,</span>
            <span class="n">centroid_model</span><span class="o">=</span><span class="n">centroid_model</span><span class="p">,</span>
            <span class="n">confmap_config</span><span class="o">=</span><span class="n">confmap_config</span><span class="p">,</span>
            <span class="n">confmap_model</span><span class="o">=</span><span class="n">confmap_model</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">peak_threshold</span><span class="o">=</span><span class="n">peak_threshold</span><span class="p">,</span>
            <span class="n">integral_refinement</span><span class="o">=</span><span class="n">integral_refinement</span><span class="p">,</span>
            <span class="n">integral_patch_size</span><span class="o">=</span><span class="n">integral_patch_size</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_initialize_topdown_model</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">obj</span></div>

    <span class="k">def</span> <span class="nf">make_pipeline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_provider</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Provider</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Pipeline</span><span class="p">:</span>

        <span class="n">keep_original_image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracker</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracker</span><span class="o">.</span><span class="n">uses_image</span>

        <span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">data_provider</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pipeline</span><span class="o">.</span><span class="n">providers</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_provider</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pipeline</span> <span class="o">+=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pipelines</span><span class="o">.</span><span class="n">InstanceCentroidFinder</span><span class="p">(</span>
                <span class="n">center_on_anchor_part</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">confmap_config</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">instance_cropping</span><span class="o">.</span><span class="n">center_on_part</span>
                <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">anchor_part_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">confmap_config</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">instance_cropping</span><span class="o">.</span><span class="n">center_on_part</span><span class="p">,</span>
                <span class="n">skeletons</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">confmap_config</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">skeletons</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">pipeline</span> <span class="o">+=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pipelines</span><span class="o">.</span><span class="n">Batcher</span><span class="p">(</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">drop_remainder</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unrag</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="n">pipeline</span> <span class="o">+=</span> <span class="n">Prefetcher</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">pipeline</span>

        <span class="k">return</span> <span class="n">pipeline</span>

    <span class="k">def</span> <span class="nf">predict_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_provider</span><span class="p">:</span> <span class="n">Provider</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_config</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">confmap_config</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">make_pipeline</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Pass in data provider when mocking one of the models.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">make_pipeline</span><span class="p">(</span><span class="n">data_provider</span><span class="o">=</span><span class="n">data_provider</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">providers</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_provider</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">topdown_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_topdown_model</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">ex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">make_dataset</span><span class="p">():</span>
            <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topdown_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>

            <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;instance_peaks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">x</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">preds</span><span class="p">[</span><span class="s2">&quot;instance_peaks&quot;</span><span class="p">],</span> <span class="n">preds</span><span class="p">[</span><span class="s2">&quot;n_valid&quot;</span><span class="p">])</span>
            <span class="p">]</span>
            <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;instance_peak_vals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">x</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">preds</span><span class="p">[</span><span class="s2">&quot;instance_peak_vals&quot;</span><span class="p">],</span> <span class="n">preds</span><span class="p">[</span><span class="s2">&quot;n_valid&quot;</span><span class="p">])</span>
            <span class="p">]</span>
            <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;centroids&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">x</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">preds</span><span class="p">[</span><span class="s2">&quot;centroids&quot;</span><span class="p">],</span> <span class="n">preds</span><span class="p">[</span><span class="s2">&quot;n_valid&quot;</span><span class="p">])</span>
            <span class="p">]</span>
            <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;centroid_vals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">x</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">preds</span><span class="p">[</span><span class="s2">&quot;centroid_vals&quot;</span><span class="p">],</span> <span class="n">preds</span><span class="p">[</span><span class="s2">&quot;n_valid&quot;</span><span class="p">])</span>
            <span class="p">]</span>

            <span class="k">yield</span> <span class="n">ex</span>

    <span class="k">def</span> <span class="nf">make_labeled_frames_from_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">data_provider</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">confmap_config</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skeleton</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">confmap_config</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">skeletons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">skeleton</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_config</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">skeletons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Loop over batches.</span>
        <span class="n">predicted_frames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ex</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>

            <span class="c1"># Loop over frames.</span>
            <span class="k">for</span> <span class="n">image</span><span class="p">,</span> <span class="n">video_ind</span><span class="p">,</span> <span class="n">frame_ind</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">confidences</span><span class="p">,</span> <span class="n">scores</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">],</span>
                <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;video_ind&quot;</span><span class="p">],</span>
                <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;frame_ind&quot;</span><span class="p">],</span>
                <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;instance_peaks&quot;</span><span class="p">],</span>
                <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;instance_peak_vals&quot;</span><span class="p">],</span>
                <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;centroid_vals&quot;</span><span class="p">],</span>
            <span class="p">):</span>

                <span class="n">frame_ind</span> <span class="o">=</span> <span class="n">frame_ind</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                <span class="n">video_ind</span> <span class="o">=</span> <span class="n">video_ind</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

                <span class="c1"># Loop over instances.</span>
                <span class="n">predicted_instances</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">pts</span><span class="p">,</span> <span class="n">confs</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">confidences</span><span class="p">,</span> <span class="n">scores</span><span class="p">):</span>
                    <span class="n">predicted_instances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">sleap</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="n">PredictedInstance</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
                            <span class="n">points</span><span class="o">=</span><span class="n">pts</span><span class="p">,</span>
                            <span class="n">point_confidences</span><span class="o">=</span><span class="n">confs</span><span class="p">,</span>
                            <span class="n">instance_score</span><span class="o">=</span><span class="n">score</span><span class="p">,</span>
                            <span class="n">skeleton</span><span class="o">=</span><span class="n">skeleton</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracker</span><span class="p">:</span>
                    <span class="c1"># Set tracks for predicted instances in this frame.</span>
                    <span class="n">predicted_instances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracker</span><span class="o">.</span><span class="n">track</span><span class="p">(</span>
                        <span class="n">untracked_instances</span><span class="o">=</span><span class="n">predicted_instances</span><span class="p">,</span> <span class="n">img</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">frame_ind</span>
                    <span class="p">)</span>

                <span class="n">predicted_frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">sleap</span><span class="o">.</span><span class="n">LabeledFrame</span><span class="p">(</span>
                        <span class="n">video</span><span class="o">=</span><span class="n">data_provider</span><span class="o">.</span><span class="n">videos</span><span class="p">[</span><span class="n">video_ind</span><span class="p">],</span>
                        <span class="n">frame_idx</span><span class="o">=</span><span class="n">frame_ind</span><span class="p">,</span>
                        <span class="n">instances</span><span class="o">=</span><span class="n">predicted_instances</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracker</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracker</span><span class="o">.</span><span class="n">final_pass</span><span class="p">(</span><span class="n">predicted_frames</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">predicted_frames</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data_provider</span><span class="p">:</span> <span class="n">Provider</span><span class="p">,</span>
        <span class="n">make_instances</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">make_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">t0_gen</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_provider</span><span class="p">,</span> <span class="n">sleap</span><span class="o">.</span><span class="n">Labels</span><span class="p">):</span>
            <span class="n">data_provider</span> <span class="o">=</span> <span class="n">LabelsReader</span><span class="p">(</span><span class="n">data_provider</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_provider</span><span class="p">,</span> <span class="n">sleap</span><span class="o">.</span><span class="n">Video</span><span class="p">):</span>
            <span class="n">data_provider</span> <span class="o">=</span> <span class="n">VideoReader</span><span class="p">(</span><span class="n">data_provider</span><span class="p">)</span>

        <span class="n">generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_generator</span><span class="p">(</span><span class="n">data_provider</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">make_instances</span> <span class="ow">or</span> <span class="n">make_labels</span><span class="p">:</span>
            <span class="n">lfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_labeled_frames_from_generator</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">data_provider</span><span class="p">)</span>
            <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0_gen</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Predicted </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">lfs</span><span class="p">)</span><span class="si">}</span><span class="s2"> labeled frames in </span><span class="si">{</span><span class="n">elapsed</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> secs [</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">lfs</span><span class="p">)</span><span class="o">/</span><span class="n">elapsed</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> FPS]&quot;</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">make_labels</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sleap</span><span class="o">.</span><span class="n">Labels</span><span class="p">(</span><span class="n">lfs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lfs</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">examples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span>
            <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0_gen</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Predicted </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">examples</span><span class="p">)</span><span class="si">}</span><span class="s2"> examples in </span><span class="si">{</span><span class="n">elapsed</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> secs [</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">examples</span><span class="p">)</span><span class="o">/</span><span class="n">elapsed</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> examples/s]&quot;</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="n">examples</span></div>


<div class="viewcode-block" id="BottomUpInferenceLayer"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.BottomUpInferenceLayer">[docs]</a><span class="k">class</span> <span class="nc">BottomUpInferenceLayer</span><span class="p">(</span><span class="n">InferenceLayer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Keras layer that predicts instances from images using a trained model.</span>

<span class="sd">    This layer encapsulates all of the inference operations required for generating</span>
<span class="sd">    predictions from a centered instance confidence map model. This includes</span>
<span class="sd">    preprocessing, model forward pass, peak finding and coordinate adjustment.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        keras_model: A `tf.keras.Model` that accepts rank-4 images as input and predicts</span>
<span class="sd">            rank-4 confidence maps and part affinity fields as output.</span>
<span class="sd">        paf_scorer: A `sleap.nn.paf_grouping.PAFScorer` instance configured to group</span>
<span class="sd">            instances based on peaks and PAFs produced by the model.</span>
<span class="sd">        input_scale: Float indicating if the images should be resized before being</span>
<span class="sd">            passed to the model.</span>
<span class="sd">        cm_output_stride: Output stride of the model, denoting the scale of the output</span>
<span class="sd">            confidence maps relative to the images (after input scaling). This is used</span>
<span class="sd">            for adjusting the peak coordinates to the image grid. This will be inferred</span>
<span class="sd">            from the model shapes if not provided.</span>
<span class="sd">        paf_output_stride: Output stride of the model, denoting the scale of the output</span>
<span class="sd">            part affinity fields relative to the images (after input scaling). This is</span>
<span class="sd">            used for adjusting the peak coordinates to the PAF grid. This will be</span>
<span class="sd">            inferred from the model shapes if not provided.</span>
<span class="sd">        peak_threshold: Minimum confidence map value to consider a global peak as valid.</span>
<span class="sd">        refinement: If `None`, returns the grid-aligned peaks with no refinement. If</span>
<span class="sd">            `&quot;integral&quot;`, peaks will be refined with integral regression. If `&quot;local&quot;`,</span>
<span class="sd">            peaks will be refined with quarter pixel local gradient offset.</span>
<span class="sd">        integral_patch_size: Size of patches to crop around each rough peak for integral</span>
<span class="sd">            refinement as an integer scalar.</span>
<span class="sd">        return_confmaps: If `True`, the confidence maps will be returned together with</span>
<span class="sd">            the predicted instances. This will result in slower inference times since</span>
<span class="sd">            the data must be copied off of the GPU, but is useful for visualizing the</span>
<span class="sd">            raw output of the model.</span>
<span class="sd">        return_pafs: If `True`, the part affinity fields will be returned together with</span>
<span class="sd">            the predicted instances. This will result in slower inference times since</span>
<span class="sd">            the data must be copied off of the GPU, but is useful for visualizing the</span>
<span class="sd">            raw output of the model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keras_model</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">,</span>
        <span class="n">paf_scorer</span><span class="p">:</span> <span class="n">PAFScorer</span><span class="p">,</span>
        <span class="n">input_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">pad_to_stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">cm_output_stride</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">paf_output_stride</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">peak_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">refinement</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;local&quot;</span><span class="p">,</span>
        <span class="n">integral_patch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">return_confmaps</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_pafs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">keras_model</span><span class="o">=</span><span class="n">keras_model</span><span class="p">,</span>
            <span class="n">input_scale</span><span class="o">=</span><span class="n">input_scale</span><span class="p">,</span>
            <span class="n">pad_to_stride</span><span class="o">=</span><span class="n">pad_to_stride</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paf_scorer</span> <span class="o">=</span> <span class="n">paf_scorer</span>
        <span class="k">if</span> <span class="n">cm_output_stride</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Attempt to automatically infer the output stride.</span>
            <span class="n">cm_output_stride</span> <span class="o">=</span> <span class="n">get_model_output_stride</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keras_model</span><span class="p">,</span> <span class="n">output_ind</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cm_output_stride</span> <span class="o">=</span> <span class="n">cm_output_stride</span>
        <span class="k">if</span> <span class="n">paf_output_stride</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Attempt to automatically infer the output stride.</span>
            <span class="n">paf_output_stride</span> <span class="o">=</span> <span class="n">get_model_output_stride</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keras_model</span><span class="p">,</span> <span class="n">output_ind</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paf_output_stride</span> <span class="o">=</span> <span class="n">paf_output_stride</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">peak_threshold</span> <span class="o">=</span> <span class="n">peak_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refinement</span> <span class="o">=</span> <span class="n">refinement</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integral_patch_size</span> <span class="o">=</span> <span class="n">integral_patch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_confmaps</span> <span class="o">=</span> <span class="n">return_confmaps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_pafs</span> <span class="o">=</span> <span class="n">return_pafs</span>

<div class="viewcode-block" id="BottomUpInferenceLayer.call"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.BottomUpInferenceLayer.call">[docs]</a>    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Predict instances for one batch of images.</span>

<span class="sd">        Args:</span>
<span class="sd">            example: This may be either a single batch of images as a 4-D tensor of</span>
<span class="sd">                shape `(batch_size, height, width, channels)`, or a dictionary</span>
<span class="sd">                containing the image batch in the `&quot;images&quot;` key.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The predicted instances as a dictionary of tensors with keys:</span>

<span class="sd">            `&quot;instance_peaks&quot;: (batch_size, n_instances, n_nodes, 2)`: Instance skeleton</span>
<span class="sd">                points.</span>
<span class="sd">            `&quot;instance_peak_vals&quot;: (batch_size, n_instances, n_nodes)`: Confidence</span>
<span class="sd">                values for the instance skeleton points.</span>
<span class="sd">            `&quot;instance_scores&quot;: (batch_size, n_instances)`: PAF matching score for each</span>
<span class="sd">                instance.</span>

<span class="sd">            If `BottomUpInferenceLayer.return_confmaps` is `True`, the predicted</span>
<span class="sd">            confidence maps will be returned in the `&quot;confmaps&quot;` key.</span>

<span class="sd">            If `BottomUpInferenceLayer.return_pafs` is `True`, the predicted PAFs will</span>
<span class="sd">            be returned in the `&quot;part_affinity_fields&quot;` key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">imgs</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">imgs</span> <span class="o">=</span> <span class="n">data</span>

        <span class="c1"># Preprocess full images.</span>
        <span class="n">imgs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>

        <span class="c1"># Model forward pass.</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keras_model</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>
        <span class="n">cms</span><span class="p">,</span> <span class="n">pafs</span> <span class="o">=</span> <span class="n">preds</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cms</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">cms</span> <span class="o">=</span> <span class="n">cms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pafs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">pafs</span> <span class="o">=</span> <span class="n">pafs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Find local peaks.</span>
        <span class="p">(</span>
            <span class="n">peaks</span><span class="p">,</span>
            <span class="n">peak_vals</span><span class="p">,</span>
            <span class="n">peak_sample_inds</span><span class="p">,</span>
            <span class="n">peak_channel_inds</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">peak_finding</span><span class="o">.</span><span class="n">find_local_peaks</span><span class="p">(</span>
            <span class="n">cms</span><span class="p">,</span>
            <span class="n">threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">peak_threshold</span><span class="p">,</span>
            <span class="n">refinement</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">refinement</span><span class="p">,</span>
            <span class="n">integral_patch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">integral_patch_size</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Adjust for confidence map output stride.</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">peaks</span> <span class="o">*</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cm_output_stride</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># Group peaks by sample.</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pafs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
            <span class="n">peaks</span><span class="p">,</span> <span class="n">peak_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">samples</span>
        <span class="p">)</span>
        <span class="n">peak_vals</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
            <span class="n">peak_vals</span><span class="p">,</span> <span class="n">peak_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">samples</span>
        <span class="p">)</span>
        <span class="n">peak_channel_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
            <span class="n">peak_channel_inds</span><span class="p">,</span> <span class="n">peak_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">samples</span>
        <span class="p">)</span>

        <span class="c1"># Group peaks into instances via PAF scoring.</span>
        <span class="p">(</span>
            <span class="n">instance_peaks</span><span class="p">,</span>
            <span class="n">instance_peak_vals</span><span class="p">,</span>
            <span class="n">instance_scores</span><span class="p">,</span>
            <span class="n">instance_sample_inds</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paf_scorer</span><span class="o">.</span><span class="n">group_peaks</span><span class="p">(</span><span class="n">pafs</span><span class="p">,</span> <span class="n">peaks</span><span class="p">,</span> <span class="n">peak_vals</span><span class="p">,</span> <span class="n">peak_channel_inds</span><span class="p">)</span>

        <span class="c1"># Adjust for input scaling.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_scale</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="c1"># Note: We add 0.5 here to offset TensorFlow&#39;s weird image resizing. This</span>
            <span class="c1"># may not always(?) be the most correct approach.</span>
            <span class="c1"># See: https://github.com/tensorflow/tensorflow/issues/6720</span>
            <span class="n">instance_peaks</span> <span class="o">=</span> <span class="p">(</span><span class="n">instance_peaks</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_scale</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span>

        <span class="c1"># Group instances by sample.</span>
        <span class="n">instance_peaks</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
            <span class="n">instance_peaks</span><span class="p">,</span> <span class="n">instance_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">samples</span>
        <span class="p">)</span>
        <span class="n">instance_peak_vals</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
            <span class="n">instance_peak_vals</span><span class="p">,</span> <span class="n">instance_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">samples</span>
        <span class="p">)</span>
        <span class="n">instance_scores</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">RaggedTensor</span><span class="o">.</span><span class="n">from_value_rowids</span><span class="p">(</span>
            <span class="n">instance_scores</span><span class="p">,</span> <span class="n">instance_sample_inds</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">samples</span>
        <span class="p">)</span>

        <span class="c1"># Build outputs and return.</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;instance_peaks&quot;</span><span class="p">:</span> <span class="n">instance_peaks</span><span class="p">,</span>
            <span class="s2">&quot;instance_peak_vals&quot;</span><span class="p">:</span> <span class="n">instance_peak_vals</span><span class="p">,</span>
            <span class="s2">&quot;instance_scores&quot;</span><span class="p">:</span> <span class="n">instance_scores</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_confmaps</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="s2">&quot;confmaps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cms</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_pafs</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="s2">&quot;part_affinity_fields&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pafs</span>
        <span class="k">return</span> <span class="n">out</span></div></div>


<div class="viewcode-block" id="BottomUpInferenceModel"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.BottomUpInferenceModel">[docs]</a><span class="k">class</span> <span class="nc">BottomUpInferenceModel</span><span class="p">(</span><span class="n">InferenceModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Bottom-up instance prediction model.</span>

<span class="sd">    This model encapsulates the bottom-up approach where points are first detected by</span>
<span class="sd">    local peak detection and then grouped into instances by connectivity scoring using</span>
<span class="sd">    part affinity fields.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        bottomup_layer: A `BottomUpInferenceLayer`. This layer takes as input a full</span>
<span class="sd">            image and outputs the predicted instances.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bottomup_layer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bottomup_layer</span> <span class="o">=</span> <span class="n">bottomup_layer</span>

<div class="viewcode-block" id="BottomUpInferenceModel.call"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.BottomUpInferenceModel.call">[docs]</a>    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">example</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Predict instances for one batch of images.</span>

<span class="sd">        Args:</span>
<span class="sd">            example: This may be either a single batch of images as a 4-D tensor of</span>
<span class="sd">                shape `(batch_size, height, width, channels)`, or a dictionary</span>
<span class="sd">                containing the image batch in the `&quot;images&quot;` key.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The predicted instances as a dictionary of tensors with keys:</span>

<span class="sd">            `&quot;instance_peaks&quot;: (batch_size, n_instances, n_nodes, 2)`: Instance skeleton</span>
<span class="sd">                points.</span>
<span class="sd">            `&quot;instance_peak_vals&quot;: (batch_size, n_instances, n_nodes)`: Confidence</span>
<span class="sd">                values for the instance skeleton points.</span>
<span class="sd">            `&quot;instance_scores&quot;: (batch_size, n_instances)`: PAF matching score for each</span>
<span class="sd">                instance.</span>

<span class="sd">            If `BottomUpInferenceModel.bottomup_layer.return_confmaps` is `True`, the</span>
<span class="sd">            predicted confidence maps will be returned in the `&quot;confmaps&quot;` key.</span>

<span class="sd">            If `BottomUpInferenceModel.bottomup_layer.return_pafs` is `True`, the</span>
<span class="sd">            predicted PAFs will be returned in the `&quot;part_affinity_fields&quot;` key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="n">example</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">example</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bottomup_layer</span><span class="p">(</span><span class="n">example</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="BottomupPredictor"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.BottomupPredictor">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">BottomupPredictor</span><span class="p">(</span><span class="n">Predictor</span><span class="p">):</span>
    <span class="n">bottomup_config</span><span class="p">:</span> <span class="n">TrainingJobConfig</span>
    <span class="n">bottomup_model</span><span class="p">:</span> <span class="n">Model</span>
    <span class="n">inference_model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">BottomUpInferenceModel</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">pipeline</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Pipeline</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">tracker</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tracker</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">peak_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span>
    <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">integral_refinement</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">integral_patch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="k">def</span> <span class="nf">_initialize_inference_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inference_model</span> <span class="o">=</span> <span class="n">BottomUpInferenceModel</span><span class="p">(</span>
            <span class="n">BottomUpInferenceLayer</span><span class="p">(</span>
                <span class="n">keras_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bottomup_model</span><span class="o">.</span><span class="n">keras_model</span><span class="p">,</span>
                <span class="n">paf_scorer</span><span class="o">=</span><span class="n">PAFScorer</span><span class="o">.</span><span class="n">from_config</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bottomup_config</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">heads</span><span class="o">.</span><span class="n">multi_instance</span><span class="p">,</span>
                    <span class="n">max_edge_length</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span>
                    <span class="n">min_edge_score</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
                    <span class="n">n_points</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                    <span class="n">min_instance_peaks</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">input_scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bottomup_config</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">input_scaling</span><span class="p">,</span>
                <span class="n">pad_to_stride</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bottomup_model</span><span class="o">.</span><span class="n">maximum_stride</span><span class="p">,</span>
                <span class="n">refinement</span><span class="o">=</span><span class="s2">&quot;integral&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">integral_refinement</span> <span class="k">else</span> <span class="s2">&quot;local&quot;</span><span class="p">,</span>
                <span class="n">integral_patch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">integral_patch_size</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

<div class="viewcode-block" id="BottomupPredictor.from_trained_models"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.BottomupPredictor.from_trained_models">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_trained_models</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">bottomup_model_path</span><span class="p">:</span> <span class="n">Text</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">peak_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">integral_refinement</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">integral_patch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BottomupPredictor&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create predictor from saved models.&quot;&quot;&quot;</span>
        <span class="c1"># Load bottomup model.</span>
        <span class="n">bottomup_config</span> <span class="o">=</span> <span class="n">TrainingJobConfig</span><span class="o">.</span><span class="n">load_json</span><span class="p">(</span><span class="n">bottomup_model_path</span><span class="p">)</span>
        <span class="n">bottomup_keras_model_path</span> <span class="o">=</span> <span class="n">get_keras_model_path</span><span class="p">(</span><span class="n">bottomup_model_path</span><span class="p">)</span>
        <span class="n">bottomup_model</span> <span class="o">=</span> <span class="n">Model</span><span class="o">.</span><span class="n">from_config</span><span class="p">(</span><span class="n">bottomup_config</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="n">bottomup_model</span><span class="o">.</span><span class="n">keras_model</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span>
            <span class="n">bottomup_keras_model_path</span><span class="p">,</span> <span class="nb">compile</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">bottomup_config</span><span class="o">=</span><span class="n">bottomup_config</span><span class="p">,</span>
            <span class="n">bottomup_model</span><span class="o">=</span><span class="n">bottomup_model</span><span class="p">,</span>
            <span class="n">peak_threshold</span><span class="o">=</span><span class="n">peak_threshold</span><span class="p">,</span>
            <span class="n">integral_refinement</span><span class="o">=</span><span class="n">integral_refinement</span><span class="p">,</span>
            <span class="n">integral_patch_size</span><span class="o">=</span><span class="n">integral_patch_size</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_initialize_inference_model</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">obj</span></div>

    <span class="k">def</span> <span class="nf">make_pipeline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_provider</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Provider</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Pipeline</span><span class="p">:</span>
        <span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">data_provider</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pipeline</span><span class="o">.</span><span class="n">providers</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_provider</span><span class="p">]</span>

        <span class="n">pipeline</span> <span class="o">+=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pipelines</span><span class="o">.</span><span class="n">Batcher</span><span class="p">(</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">drop_remainder</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unrag</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="n">pipeline</span> <span class="o">+=</span> <span class="n">Prefetcher</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">pipeline</span>

        <span class="k">return</span> <span class="n">pipeline</span>

    <span class="k">def</span> <span class="nf">make_labeled_frames_from_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">data_provider</span><span class="p">):</span>

        <span class="n">skeleton</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bottomup_config</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">skeletons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Loop over batches.</span>
        <span class="n">predicted_frames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ex</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>

            <span class="c1"># Loop over frames.</span>
            <span class="k">for</span> <span class="n">image</span><span class="p">,</span> <span class="n">video_ind</span><span class="p">,</span> <span class="n">frame_ind</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">confidences</span><span class="p">,</span> <span class="n">scores</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">],</span>
                <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;video_ind&quot;</span><span class="p">],</span>
                <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;frame_ind&quot;</span><span class="p">],</span>
                <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;instance_peaks&quot;</span><span class="p">],</span>
                <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;instance_peak_vals&quot;</span><span class="p">],</span>
                <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;instance_scores&quot;</span><span class="p">],</span>
            <span class="p">):</span>

                <span class="n">frame_ind</span> <span class="o">=</span> <span class="n">frame_ind</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                <span class="n">video_ind</span> <span class="o">=</span> <span class="n">video_ind</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

                <span class="c1"># Loop over instances.</span>
                <span class="n">predicted_instances</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">pts</span><span class="p">,</span> <span class="n">confs</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">confidences</span><span class="p">,</span> <span class="n">scores</span><span class="p">):</span>
                    <span class="n">predicted_instances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">sleap</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="n">PredictedInstance</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
                            <span class="n">points</span><span class="o">=</span><span class="n">pts</span><span class="p">,</span>
                            <span class="n">point_confidences</span><span class="o">=</span><span class="n">confs</span><span class="p">,</span>
                            <span class="n">instance_score</span><span class="o">=</span><span class="n">score</span><span class="p">,</span>
                            <span class="n">skeleton</span><span class="o">=</span><span class="n">skeleton</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracker</span><span class="p">:</span>
                    <span class="c1"># Set tracks for predicted instances in this frame.</span>
                    <span class="n">predicted_instances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracker</span><span class="o">.</span><span class="n">track</span><span class="p">(</span>
                        <span class="n">untracked_instances</span><span class="o">=</span><span class="n">predicted_instances</span><span class="p">,</span> <span class="n">img</span><span class="o">=</span><span class="n">image</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">frame_ind</span>
                    <span class="p">)</span>

                <span class="n">predicted_frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">sleap</span><span class="o">.</span><span class="n">LabeledFrame</span><span class="p">(</span>
                        <span class="n">video</span><span class="o">=</span><span class="n">data_provider</span><span class="o">.</span><span class="n">videos</span><span class="p">[</span><span class="n">video_ind</span><span class="p">],</span>
                        <span class="n">frame_idx</span><span class="o">=</span><span class="n">frame_ind</span><span class="p">,</span>
                        <span class="n">instances</span><span class="o">=</span><span class="n">predicted_instances</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracker</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracker</span><span class="o">.</span><span class="n">final_pass</span><span class="p">(</span><span class="n">predicted_frames</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">predicted_frames</span>

    <span class="k">def</span> <span class="nf">predict_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_provider</span><span class="p">:</span> <span class="n">Provider</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_pipeline</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_inference_model</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">providers</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_provider</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">ex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">make_dataset</span><span class="p">():</span>
            <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>

            <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;instance_peaks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">x</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">preds</span><span class="p">[</span><span class="s2">&quot;instance_peaks&quot;</span><span class="p">],</span> <span class="n">preds</span><span class="p">[</span><span class="s2">&quot;n_valid&quot;</span><span class="p">])</span>
            <span class="p">]</span>
            <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;instance_peak_vals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">x</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">preds</span><span class="p">[</span><span class="s2">&quot;instance_peak_vals&quot;</span><span class="p">],</span> <span class="n">preds</span><span class="p">[</span><span class="s2">&quot;n_valid&quot;</span><span class="p">])</span>
            <span class="p">]</span>
            <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;instance_scores&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">x</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">preds</span><span class="p">[</span><span class="s2">&quot;instance_scores&quot;</span><span class="p">],</span> <span class="n">preds</span><span class="p">[</span><span class="s2">&quot;n_valid&quot;</span><span class="p">])</span>
            <span class="p">]</span>
            <span class="k">yield</span> <span class="n">ex</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data_provider</span><span class="p">:</span> <span class="n">Provider</span><span class="p">,</span>
        <span class="n">make_instances</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">make_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_provider</span><span class="p">,</span> <span class="n">sleap</span><span class="o">.</span><span class="n">Labels</span><span class="p">):</span>
            <span class="n">data_provider</span> <span class="o">=</span> <span class="n">LabelsReader</span><span class="p">(</span><span class="n">data_provider</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_provider</span><span class="p">,</span> <span class="n">sleap</span><span class="o">.</span><span class="n">Video</span><span class="p">):</span>
            <span class="n">data_provider</span> <span class="o">=</span> <span class="n">VideoReader</span><span class="p">(</span><span class="n">data_provider</span><span class="p">)</span>
        <span class="n">generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_generator</span><span class="p">(</span><span class="n">data_provider</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">make_instances</span> <span class="ow">or</span> <span class="n">make_labels</span><span class="p">:</span>
            <span class="n">lfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_labeled_frames_from_generator</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">data_provider</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">make_labels</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sleap</span><span class="o">.</span><span class="n">Labels</span><span class="p">(</span><span class="n">lfs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lfs</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span></div>


<div class="viewcode-block" id="SingleInstanceInferenceLayer"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.SingleInstanceInferenceLayer">[docs]</a><span class="k">class</span> <span class="nc">SingleInstanceInferenceLayer</span><span class="p">(</span><span class="n">InferenceLayer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Inference layer for applying single instance models.</span>

<span class="sd">    This layer encapsulates all of the inference operations requires for generating</span>
<span class="sd">    predictions from a single instance confidence map model. This includes</span>
<span class="sd">    preprocessing, model forward pass, peak finding and coordinate adjustment.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        keras_model: A `tf.keras.Model` that accepts rank-4 images as input and predicts</span>
<span class="sd">            rank-4 confidence maps as output. This should be a model that is trained on</span>
<span class="sd">            single instance confidence maps.</span>
<span class="sd">        input_scale: Float indicating if the images should be resized before being</span>
<span class="sd">            passed to the model.</span>
<span class="sd">        pad_to_stride: If not 1, input image will be paded to ensure that it is</span>
<span class="sd">            divisible by this value (after scaling). This should be set to the max</span>
<span class="sd">            stride of the model.</span>
<span class="sd">        output_stride: Output stride of the model, denoting the scale of the output</span>
<span class="sd">            confidence maps relative to the images (after input scaling). This is used</span>
<span class="sd">            for adjusting the peak coordinates to the image grid. This will be inferred</span>
<span class="sd">            from the model shapes if not provided.</span>
<span class="sd">        peak_threshold: Minimum confidence map value to consider a global peak as valid.</span>
<span class="sd">        refinement: If `None`, returns the grid-aligned peaks with no refinement. If</span>
<span class="sd">            `&quot;integral&quot;`, peaks will be refined with integral regression. If `&quot;local&quot;`,</span>
<span class="sd">            peaks will be refined with quarter pixel local gradient offset.</span>
<span class="sd">        integral_patch_size: Size of patches to crop around each rough peak for integral</span>
<span class="sd">            refinement as an integer scalar.</span>
<span class="sd">        return_confmaps: If `True`, the confidence maps will be returned together with</span>
<span class="sd">            the predicted peaks. This will result in slower inference times since the</span>
<span class="sd">            data must be copied off of the GPU, but is useful for visualizing the raw</span>
<span class="sd">            output of the model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keras_model</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">,</span>
        <span class="n">input_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">pad_to_stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">output_stride</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">peak_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">refinement</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;local&quot;</span><span class="p">,</span>
        <span class="n">integral_patch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">return_confmaps</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">keras_model</span><span class="o">=</span><span class="n">keras_model</span><span class="p">,</span>
            <span class="n">input_scale</span><span class="o">=</span><span class="n">input_scale</span><span class="p">,</span>
            <span class="n">pad_to_stride</span><span class="o">=</span><span class="n">pad_to_stride</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">output_stride</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Attempt to automatically infer the output stride.</span>
            <span class="n">output_stride</span> <span class="o">=</span> <span class="n">get_model_output_stride</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keras_model</span><span class="p">,</span> <span class="n">output_ind</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_stride</span> <span class="o">=</span> <span class="n">output_stride</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">peak_threshold</span> <span class="o">=</span> <span class="n">peak_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refinement</span> <span class="o">=</span> <span class="n">refinement</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integral_patch_size</span> <span class="o">=</span> <span class="n">integral_patch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_confmaps</span> <span class="o">=</span> <span class="n">return_confmaps</span>

<div class="viewcode-block" id="SingleInstanceInferenceLayer.call"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.SingleInstanceInferenceLayer.call">[docs]</a>    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Predict instance confidence maps and find peaks.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputs: Full frame images as a `tf.Tensor` of shape</span>
<span class="sd">                `(samples, height, width, channels)` or a dictionary with key:</span>
<span class="sd">                `&quot;image&quot;`: Full frame images in the same format as above.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary of outputs grouped by sample with keys:</span>

<span class="sd">            `&quot;peaks&quot;`: The predicted peaks of shape `(samples, nodes, 2)`.</span>
<span class="sd">            `&quot;peak_vals&quot;: The peak confidence values of shape `(samples, nodes)`.</span>

<span class="sd">            If the `return_confmaps` attribute is set to `True`, the output will also</span>
<span class="sd">            contain a key named `&quot;confmaps&quot;` containing a `tf.Tensor` of shape</span>
<span class="sd">            `(samples, output_height, output_width, 1)` containing the confidence maps</span>
<span class="sd">            predicted by the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">imgs</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">imgs</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">imgs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keras_model</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>
        <span class="n">cms</span> <span class="o">=</span> <span class="n">preds</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cms</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">cms</span> <span class="o">=</span> <span class="n">cms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">peaks</span><span class="p">,</span> <span class="n">peak_vals</span> <span class="o">=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">peak_finding</span><span class="o">.</span><span class="n">find_global_peaks</span><span class="p">(</span>
            <span class="n">cms</span><span class="p">,</span>
            <span class="n">threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">peak_threshold</span><span class="p">,</span>
            <span class="n">refinement</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">refinement</span><span class="p">,</span>
            <span class="n">integral_patch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">integral_patch_size</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;peaks&quot;</span><span class="p">:</span> <span class="n">peaks</span><span class="p">,</span> <span class="s2">&quot;peak_vals&quot;</span><span class="p">:</span> <span class="n">peak_vals</span><span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_confmaps</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="s2">&quot;confmaps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cms</span>
        <span class="k">return</span> <span class="n">out</span></div></div>


<div class="viewcode-block" id="SingleInstanceInferenceModel"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.SingleInstanceInferenceModel">[docs]</a><span class="k">class</span> <span class="nc">SingleInstanceInferenceModel</span><span class="p">(</span><span class="n">InferenceModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Single instance prediction model.</span>

<span class="sd">    This model encapsulates the basic single instance approach where it is assumed that</span>
<span class="sd">    there is only one instance in the frame. The images are passed to a peak detector</span>
<span class="sd">    which is trained to detect all body parts for the instance assuming a single peak</span>
<span class="sd">    per body part.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        single_instance_layer: A single instance instance peak detection layer. This</span>
<span class="sd">            layer takes as input full images and outputs the detected peaks.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">single_instance_layer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">single_instance_layer</span> <span class="o">=</span> <span class="n">single_instance_layer</span>

<div class="viewcode-block" id="SingleInstanceInferenceModel.call"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.SingleInstanceInferenceModel.call">[docs]</a>    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">example</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Predict instances for one batch of images.</span>

<span class="sd">        Args:</span>
<span class="sd">            example: This may be either a single batch of images as a 4-D tensor of</span>
<span class="sd">                shape `(batch_size, height, width, channels)`, or a dictionary</span>
<span class="sd">                containing the image batch in the `&quot;images&quot;` key.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The predicted instances as a dictionary of tensors with keys:</span>

<span class="sd">            `&quot;peaks&quot;: (batch_size, n_nodes, 2)`: Instance skeleton points.</span>
<span class="sd">            `&quot;peak_vals&quot;: (batch_size, n_instances, n_nodes)`: Confidence values for the</span>
<span class="sd">                instance skeleton points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_instance_layer</span><span class="p">(</span><span class="n">example</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SingleInstancePredictor"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.SingleInstancePredictor">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">SingleInstancePredictor</span><span class="p">(</span><span class="n">Predictor</span><span class="p">):</span>
    <span class="n">confmap_config</span><span class="p">:</span> <span class="n">TrainingJobConfig</span>
    <span class="n">confmap_model</span><span class="p">:</span> <span class="n">Model</span>
    <span class="n">inference_model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SingleInstanceInferenceModel</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">pipeline</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Pipeline</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">peak_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span>
    <span class="n">integral_refinement</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">integral_patch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span>

    <span class="k">def</span> <span class="nf">_initialize_inference_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inference_model</span> <span class="o">=</span> <span class="n">SingleInstanceInferenceModel</span><span class="p">(</span>
            <span class="n">SingleInstanceInferenceLayer</span><span class="p">(</span>
                <span class="n">keras_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">confmap_model</span><span class="o">.</span><span class="n">keras_model</span><span class="p">,</span>
                <span class="n">input_scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">confmap_config</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">preprocessing</span><span class="o">.</span><span class="n">input_scaling</span><span class="p">,</span>
                <span class="n">pad_to_stride</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">confmap_model</span><span class="o">.</span><span class="n">maximum_stride</span><span class="p">,</span>
                <span class="n">refinement</span><span class="o">=</span><span class="s2">&quot;integral&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">integral_refinement</span> <span class="k">else</span> <span class="s2">&quot;local&quot;</span><span class="p">,</span>
                <span class="n">integral_patch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">integral_patch_size</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

<div class="viewcode-block" id="SingleInstancePredictor.from_trained_models"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.SingleInstancePredictor.from_trained_models">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_trained_models</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">confmap_model_path</span><span class="p">:</span> <span class="n">Text</span><span class="p">,</span>
        <span class="n">peak_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">integral_refinement</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">integral_patch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;SingleInstancePredictor&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create predictor from saved models.&quot;&quot;&quot;</span>
        <span class="c1"># Load confmap model.</span>
        <span class="n">confmap_config</span> <span class="o">=</span> <span class="n">TrainingJobConfig</span><span class="o">.</span><span class="n">load_json</span><span class="p">(</span><span class="n">confmap_model_path</span><span class="p">)</span>
        <span class="n">confmap_keras_model_path</span> <span class="o">=</span> <span class="n">get_keras_model_path</span><span class="p">(</span><span class="n">confmap_model_path</span><span class="p">)</span>
        <span class="n">confmap_model</span> <span class="o">=</span> <span class="n">Model</span><span class="o">.</span><span class="n">from_config</span><span class="p">(</span><span class="n">confmap_config</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="n">confmap_model</span><span class="o">.</span><span class="n">keras_model</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span>
            <span class="n">confmap_keras_model_path</span><span class="p">,</span> <span class="nb">compile</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">confmap_config</span><span class="o">=</span><span class="n">confmap_config</span><span class="p">,</span>
            <span class="n">confmap_model</span><span class="o">=</span><span class="n">confmap_model</span><span class="p">,</span>
            <span class="n">peak_threshold</span><span class="o">=</span><span class="n">peak_threshold</span><span class="p">,</span>
            <span class="n">integral_refinement</span><span class="o">=</span><span class="n">integral_refinement</span><span class="p">,</span>
            <span class="n">integral_patch_size</span><span class="o">=</span><span class="n">integral_patch_size</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_initialize_inference_model</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">obj</span></div>

    <span class="k">def</span> <span class="nf">make_pipeline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_provider</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Provider</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Pipeline</span><span class="p">:</span>

        <span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">data_provider</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pipeline</span><span class="o">.</span><span class="n">providers</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_provider</span><span class="p">]</span>

        <span class="n">pipeline</span> <span class="o">+=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pipelines</span><span class="o">.</span><span class="n">Batcher</span><span class="p">(</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">drop_remainder</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unrag</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="n">pipeline</span> <span class="o">+=</span> <span class="n">Prefetcher</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">pipeline</span>

        <span class="k">return</span> <span class="n">pipeline</span>

    <span class="k">def</span> <span class="nf">make_labeled_frames_from_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">data_provider</span><span class="p">):</span>

        <span class="n">skeleton</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">confmap_config</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">skeletons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Loop over batches.</span>
        <span class="n">predicted_frames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ex</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>

            <span class="c1"># Loop over frames.</span>
            <span class="k">for</span> <span class="n">video_ind</span><span class="p">,</span> <span class="n">frame_ind</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">confidences</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;video_ind&quot;</span><span class="p">],</span> <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;frame_ind&quot;</span><span class="p">],</span> <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;peaks&quot;</span><span class="p">],</span> <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;peak_vals&quot;</span><span class="p">]</span>
            <span class="p">):</span>

                <span class="n">frame_ind</span> <span class="o">=</span> <span class="n">frame_ind</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                <span class="n">video_ind</span> <span class="o">=</span> <span class="n">video_ind</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

                <span class="c1"># Loop over instances.</span>
                <span class="n">predicted_instances</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">sleap</span><span class="o">.</span><span class="n">instance</span><span class="o">.</span><span class="n">PredictedInstance</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
                        <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span>
                        <span class="n">point_confidences</span><span class="o">=</span><span class="n">confidences</span><span class="p">,</span>
                        <span class="n">instance_score</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">confidences</span><span class="p">),</span>
                        <span class="n">skeleton</span><span class="o">=</span><span class="n">skeleton</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">]</span>

                <span class="n">predicted_frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">sleap</span><span class="o">.</span><span class="n">LabeledFrame</span><span class="p">(</span>
                        <span class="n">video</span><span class="o">=</span><span class="n">data_provider</span><span class="o">.</span><span class="n">videos</span><span class="p">[</span><span class="n">video_ind</span><span class="p">],</span>
                        <span class="n">frame_idx</span><span class="o">=</span><span class="n">frame_ind</span><span class="p">,</span>
                        <span class="n">instances</span><span class="o">=</span><span class="n">predicted_instances</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">predicted_frames</span>

    <span class="k">def</span> <span class="nf">predict_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_provider</span><span class="p">:</span> <span class="n">Provider</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_pipeline</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_inference_model</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">providers</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_provider</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">ex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">make_dataset</span><span class="p">():</span>
            <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inference_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
            <span class="n">preds</span><span class="p">[</span><span class="s2">&quot;video_ind&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;video_ind&quot;</span><span class="p">]</span>
            <span class="n">preds</span><span class="p">[</span><span class="s2">&quot;frame_ind&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;frame_ind&quot;</span><span class="p">]</span>
            <span class="k">yield</span> <span class="n">preds</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data_provider</span><span class="p">:</span> <span class="n">Provider</span><span class="p">,</span>
        <span class="n">make_instances</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">make_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_provider</span><span class="p">,</span> <span class="n">sleap</span><span class="o">.</span><span class="n">Labels</span><span class="p">):</span>
            <span class="n">data_provider</span> <span class="o">=</span> <span class="n">LabelsReader</span><span class="p">(</span><span class="n">data_provider</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_provider</span><span class="p">,</span> <span class="n">sleap</span><span class="o">.</span><span class="n">Video</span><span class="p">):</span>
            <span class="n">data_provider</span> <span class="o">=</span> <span class="n">VideoReader</span><span class="p">(</span><span class="n">data_provider</span><span class="p">)</span>
        <span class="n">generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_generator</span><span class="p">(</span><span class="n">data_provider</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">make_instances</span> <span class="ow">or</span> <span class="n">make_labels</span><span class="p">:</span>
            <span class="n">lfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_labeled_frames_from_generator</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">data_provider</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">make_labels</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sleap</span><span class="o">.</span><span class="n">Labels</span><span class="p">(</span><span class="n">lfs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lfs</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span></div>


<span class="n">CLI_PREDICTORS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;topdown&quot;</span><span class="p">:</span> <span class="n">TopdownPredictor</span><span class="p">,</span>
    <span class="s2">&quot;bottomup&quot;</span><span class="p">:</span> <span class="n">BottomupPredictor</span><span class="p">,</span>
    <span class="s2">&quot;single&quot;</span><span class="p">:</span> <span class="n">SingleInstancePredictor</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">make_cli_parser</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">argparse</span>
    <span class="kn">from</span> <span class="nn">sleap.util</span> <span class="kn">import</span> <span class="n">frame_list</span>

    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>

    <span class="c1"># Add args for entire pipeline</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;video_path&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;?&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Path to video file&quot;</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-m&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--model&quot;</span><span class="p">,</span>
        <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;models&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;append&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Path to trained model directory (with training_config.json). &quot;</span>
        <span class="s2">&quot;Multiple models can be specified, each preceded by --model.&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--frames&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="n">frame_list</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;List of frames to predict. Either comma separated list (e.g. 1,2,3) or &quot;</span>
        <span class="s2">&quot;a range separated by hyphen (e.g. 1-3, for 1,2,3). (default is entire video)&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--only-labeled-frames&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Only run inference on labeled frames (when running on labels dataset file).&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--only-suggested-frames&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Only run inference on suggested frames (when running on labels dataset file).&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-o&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--output&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The output filename to use for the predicted data.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--labels&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Path to labels dataset file (for inference on multiple videos or for re-tracking pre-existing predictions).&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># TODO: better video parameters</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--video.dataset&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The dataset for HDF5 videos.&quot;</span>
    <span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--video.input_format&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The input_format for HDF5 videos.&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">device_group</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">add_mutually_exclusive_group</span><span class="p">(</span><span class="n">required</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">device_group</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--cpu&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Run inference only on CPU. If not specified, will use available GPU.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">device_group</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--first-gpu&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Run inference on the first GPU, if available.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">device_group</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--last-gpu&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Run inference on the last GPU, if available.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">device_group</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--gpu&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Run inference on the i-th GPU specified.&quot;</span>
    <span class="p">)</span>

    <span class="c1"># Add args for each predictor class</span>
    <span class="k">for</span> <span class="n">predictor_name</span><span class="p">,</span> <span class="n">predictor_class</span> <span class="ow">in</span> <span class="n">CLI_PREDICTORS</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="s2">&quot;peak_threshold&quot;</span> <span class="ow">in</span> <span class="n">attr</span><span class="o">.</span><span class="n">fields_dict</span><span class="p">(</span><span class="n">predictor_class</span><span class="p">):</span>
            <span class="c1"># get the default value to show in help string, although we&#39;ll</span>
            <span class="c1"># use None as default so that unspecified vals won&#39;t be passed to</span>
            <span class="c1"># builder.</span>
            <span class="n">default_val</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">fields_dict</span><span class="p">(</span><span class="n">predictor_class</span><span class="p">)[</span><span class="s2">&quot;peak_threshold&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">default</span>

            <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;--</span><span class="si">{</span><span class="n">predictor_name</span><span class="si">}</span><span class="s2">.peak_threshold&quot;</span><span class="p">,</span>
                <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Threshold to use when finding peaks in </span><span class="si">{</span><span class="n">predictor_class</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> (default: </span><span class="si">{</span><span class="n">default_val</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;batch_size&quot;</span> <span class="ow">in</span> <span class="n">attr</span><span class="o">.</span><span class="n">fields_dict</span><span class="p">(</span><span class="n">predictor_class</span><span class="p">):</span>
            <span class="n">default_val</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">fields_dict</span><span class="p">(</span><span class="n">predictor_class</span><span class="p">)[</span><span class="s2">&quot;batch_size&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">default</span>
            <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;--</span><span class="si">{</span><span class="n">predictor_name</span><span class="si">}</span><span class="s2">.batch_size&quot;</span><span class="p">,</span>
                <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                <span class="n">default</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Batch size to use for model inference in </span><span class="si">{</span><span class="n">predictor_class</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> (default: </span><span class="si">{</span><span class="n">default_val</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="c1"># Add args for tracking</span>
    <span class="n">Tracker</span><span class="o">.</span><span class="n">add_cli_parser_args</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">arg_scope</span><span class="o">=</span><span class="s2">&quot;tracking&quot;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--test-pipeline&quot;</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Test pipeline construction without running anything.&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">parser</span>


<span class="k">def</span> <span class="nf">make_video_readers_from_cli</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">VideoReader</span><span class="p">]:</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">video_path</span><span class="p">:</span>
        <span class="c1"># TODO: better support for video params</span>
        <span class="n">video_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">dataset</span><span class="o">=</span><span class="nb">vars</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;video.dataset&quot;</span><span class="p">),</span>
            <span class="n">input_format</span><span class="o">=</span><span class="nb">vars</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;video.input_format&quot;</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="n">video_reader</span> <span class="o">=</span> <span class="n">VideoReader</span><span class="o">.</span><span class="n">from_filepath</span><span class="p">(</span>
            <span class="n">filename</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">video_path</span><span class="p">,</span> <span class="n">example_indices</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">frames</span><span class="p">,</span> <span class="o">**</span><span class="n">video_kwargs</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">video_reader</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">Labels</span><span class="o">.</span><span class="n">load_file</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>

        <span class="n">readers</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">only_labeled_frames</span><span class="p">:</span>
            <span class="n">user_labeled_frames</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">user_labeled_frames</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">user_labeled_frames</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">video</span> <span class="ow">in</span> <span class="n">labels</span><span class="o">.</span><span class="n">videos</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">only_labeled_frames</span><span class="p">:</span>
                <span class="n">frame_indices</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">lf</span><span class="o">.</span><span class="n">frame_idx</span> <span class="k">for</span> <span class="n">lf</span> <span class="ow">in</span> <span class="n">user_labeled_frames</span> <span class="k">if</span> <span class="n">lf</span><span class="o">.</span><span class="n">video</span> <span class="o">==</span> <span class="n">video</span>
                <span class="p">]</span>
                <span class="n">readers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">VideoReader</span><span class="p">(</span><span class="n">video</span><span class="o">=</span><span class="n">video</span><span class="p">,</span> <span class="n">example_indices</span><span class="o">=</span><span class="n">frame_indices</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">args</span><span class="o">.</span><span class="n">only_suggested_frames</span><span class="p">:</span>
                <span class="n">readers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">VideoReader</span><span class="p">(</span>
                        <span class="n">video</span><span class="o">=</span><span class="n">video</span><span class="p">,</span> <span class="n">example_indices</span><span class="o">=</span><span class="n">labels</span><span class="o">.</span><span class="n">get_video_suggestions</span><span class="p">(</span><span class="n">video</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">readers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">VideoReader</span><span class="p">(</span><span class="n">video</span><span class="o">=</span><span class="n">video</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">readers</span>

    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You must specify either video_path or labels dataset path.&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="make_predictor_from_paths"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.make_predictor_from_paths">[docs]</a><span class="k">def</span> <span class="nf">make_predictor_from_paths</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Predictor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Builds predictor object from a list of model paths.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">make_predictor_from_models</span><span class="p">(</span><span class="n">find_heads_for_model_paths</span><span class="p">(</span><span class="n">paths</span><span class="p">))</span></div>


<div class="viewcode-block" id="find_heads_for_model_paths"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.find_heads_for_model_paths">[docs]</a><span class="k">def</span> <span class="nf">find_heads_for_model_paths</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Given list of models paths, returns dict with path keyed by head name.&quot;&quot;&quot;</span>

    <span class="n">trained_model_paths</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">paths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">trained_model_paths</span>

    <span class="k">for</span> <span class="n">model_path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
        <span class="c1"># Load the model config</span>
        <span class="n">cfg</span> <span class="o">=</span> <span class="n">TrainingJobConfig</span><span class="o">.</span><span class="n">load_json</span><span class="p">(</span><span class="n">model_path</span><span class="p">)</span>

        <span class="c1"># Get the head from the model (i.e., what the model will predict)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">heads</span><span class="o">.</span><span class="n">which_oneof_attrib_name</span><span class="p">()</span>

        <span class="c1"># If path is to config file json, then get the path to parent dir</span>
        <span class="k">if</span> <span class="n">model_path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.json&quot;</span><span class="p">):</span>
            <span class="n">model_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">model_path</span><span class="p">)</span>

        <span class="n">trained_model_paths</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_path</span>

    <span class="k">return</span> <span class="n">trained_model_paths</span></div>


<div class="viewcode-block" id="make_predictor_from_models"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.make_predictor_from_models">[docs]</a><span class="k">def</span> <span class="nf">make_predictor_from_models</span><span class="p">(</span>
    <span class="n">trained_model_paths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
    <span class="n">labels_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">policy_args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Predictor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Given dict of paths keyed by head name, returns appropriate predictor.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_relevant_args</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">policy_args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">policy_args</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">policy_args</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">if</span> <span class="s2">&quot;multi_instance&quot;</span> <span class="ow">in</span> <span class="n">trained_model_paths</span><span class="p">:</span>
        <span class="n">predictor</span> <span class="o">=</span> <span class="n">BottomupPredictor</span><span class="o">.</span><span class="n">from_trained_models</span><span class="p">(</span>
            <span class="n">trained_model_paths</span><span class="p">[</span><span class="s2">&quot;multi_instance&quot;</span><span class="p">],</span> <span class="o">**</span><span class="n">get_relevant_args</span><span class="p">(</span><span class="s2">&quot;bottomup&quot;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="s2">&quot;single_instance&quot;</span> <span class="ow">in</span> <span class="n">trained_model_paths</span><span class="p">:</span>
        <span class="n">predictor</span> <span class="o">=</span> <span class="n">SingleInstancePredictor</span><span class="o">.</span><span class="n">from_trained_models</span><span class="p">(</span>
            <span class="n">confmap_model_path</span><span class="o">=</span><span class="n">trained_model_paths</span><span class="p">[</span><span class="s2">&quot;single_instance&quot;</span><span class="p">],</span>
            <span class="o">**</span><span class="n">get_relevant_args</span><span class="p">(</span><span class="s2">&quot;single&quot;</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span>
        <span class="s2">&quot;centroid&quot;</span> <span class="ow">in</span> <span class="n">trained_model_paths</span> <span class="ow">and</span> <span class="s2">&quot;centered_instance&quot;</span> <span class="ow">in</span> <span class="n">trained_model_paths</span>
    <span class="p">):</span>
        <span class="n">predictor</span> <span class="o">=</span> <span class="n">TopdownPredictor</span><span class="o">.</span><span class="n">from_trained_models</span><span class="p">(</span>
            <span class="n">centroid_model_path</span><span class="o">=</span><span class="n">trained_model_paths</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">],</span>
            <span class="n">confmap_model_path</span><span class="o">=</span><span class="n">trained_model_paths</span><span class="p">[</span><span class="s2">&quot;centered_instance&quot;</span><span class="p">],</span>
            <span class="o">**</span><span class="n">get_relevant_args</span><span class="p">(</span><span class="s2">&quot;topdown&quot;</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">trained_model_paths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">labels_path</span><span class="p">:</span>
        <span class="n">predictor</span> <span class="o">=</span> <span class="n">MockPredictor</span><span class="o">.</span><span class="n">from_trained_models</span><span class="p">(</span><span class="n">labels_path</span><span class="o">=</span><span class="n">labels_path</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unable to run inference with </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">trained_model_paths</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2"> heads.&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">predictor</span></div>


<span class="k">def</span> <span class="nf">make_tracker_from_cli</span><span class="p">(</span><span class="n">policy_args</span><span class="p">):</span>
    <span class="k">if</span> <span class="s2">&quot;tracking&quot;</span> <span class="ow">in</span> <span class="n">policy_args</span><span class="p">:</span>
        <span class="n">tracker</span> <span class="o">=</span> <span class="n">Tracker</span><span class="o">.</span><span class="n">make_tracker_by_name</span><span class="p">(</span><span class="o">**</span><span class="n">policy_args</span><span class="p">[</span><span class="s2">&quot;tracking&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">tracker</span>

    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">save_predictions_from_cli</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">predicted_frames</span><span class="p">,</span> <span class="n">prediction_metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">sleap</span> <span class="kn">import</span> <span class="n">Labels</span>

    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">output</span>
    <span class="k">elif</span> <span class="n">args</span><span class="o">.</span><span class="n">video_path</span><span class="p">:</span>
        <span class="n">out_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">video_path</span><span class="p">)</span>
        <span class="n">out_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">video_path</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.predictions.slp&quot;</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">out_name</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">args</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span>
        <span class="n">out_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">out_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.predictions.slp&quot;</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">out_name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># We shouldn&#39;t ever get here but if we do, just save in working dir.</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="s2">&quot;predictions.slp&quot;</span>

    <span class="n">labels</span> <span class="o">=</span> <span class="n">Labels</span><span class="p">(</span><span class="n">labeled_frames</span><span class="o">=</span><span class="n">predicted_frames</span><span class="p">,</span> <span class="n">provenance</span><span class="o">=</span><span class="n">prediction_metadata</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saving: </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">Labels</span><span class="o">.</span><span class="n">save_file</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">output_path</span><span class="p">)</span>


<div class="viewcode-block" id="main"><a class="viewcode-back" href="../../../_autosummary/sleap.nn.inference.html#sleap.nn.inference.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;CLI for running inference.&quot;&quot;&quot;</span>

    <span class="n">parser</span> <span class="o">=</span> <span class="n">make_cli_parser</span><span class="p">()</span>
    <span class="n">args</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_known_args</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">cpu</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">is_gpu_system</span><span class="p">():</span>
        <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">use_cpu_only</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">first_gpu</span><span class="p">:</span>
            <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">use_first_gpu</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">args</span><span class="o">.</span><span class="n">last_gpu</span><span class="p">:</span>
            <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">use_last_gpu</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">use_gpu</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">gpu</span><span class="p">)</span>
    <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">disable_preallocation</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;System:&quot;</span><span class="p">)</span>
    <span class="n">sleap</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>

    <span class="n">video_readers</span> <span class="o">=</span> <span class="n">make_video_readers_from_cli</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="c1"># Find the specified models</span>
    <span class="n">model_paths_by_head</span> <span class="o">=</span> <span class="n">find_heads_for_model_paths</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">models</span><span class="p">)</span>

    <span class="c1"># Make a scoped dictionary with args specified from cli</span>
    <span class="n">policy_args</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">make_scoped_dictionary</span><span class="p">(</span><span class="nb">vars</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">exclude_nones</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Create appropriate predictor given these models</span>
    <span class="n">predictor</span> <span class="o">=</span> <span class="n">make_predictor_from_models</span><span class="p">(</span>
        <span class="n">model_paths_by_head</span><span class="p">,</span> <span class="n">labels_path</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span> <span class="n">policy_args</span><span class="o">=</span><span class="n">policy_args</span>
    <span class="p">)</span>

    <span class="c1"># Make the tracker</span>
    <span class="n">tracker</span> <span class="o">=</span> <span class="n">make_tracker_from_cli</span><span class="p">(</span><span class="n">policy_args</span><span class="p">)</span>
    <span class="n">predictor</span><span class="o">.</span><span class="n">tracker</span> <span class="o">=</span> <span class="n">tracker</span>

    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">test_pipeline</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">policy_args</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">predictor</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>

        <span class="n">predictor</span><span class="o">.</span><span class="n">make_pipeline</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;===pipeline transformers===&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">transformer</span> <span class="ow">in</span> <span class="n">predictor</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">transformers</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">transformer</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">-&gt; </span><span class="si">{</span><span class="n">transformer</span><span class="o">.</span><span class="n">input_keys</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">   </span><span class="si">{</span><span class="n">transformer</span><span class="o">.</span><span class="n">output_keys</span><span class="si">}</span><span class="s2"> -&gt;&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--test-pipeline arg set so stopping here.&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># Run inference!</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">predicted_frames</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">video_reader</span> <span class="ow">in</span> <span class="n">video_readers</span><span class="p">:</span>
        <span class="n">video_predicted_frames</span> <span class="o">=</span> <span class="n">predictor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">video_reader</span><span class="p">)</span>
        <span class="n">predicted_frames</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">video_predicted_frames</span><span class="p">)</span>

    <span class="c1"># Create dictionary of metadata we want to save with predictions</span>
    <span class="n">prediction_metadata</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">head</span><span class="p">,</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">model_paths_by_head</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">prediction_metadata</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;model.</span><span class="si">{</span><span class="n">head</span><span class="si">}</span><span class="s2">.path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="n">policy_args</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">policy_args</span><span class="p">[</span><span class="n">scope</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">prediction_metadata</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">scope</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="n">prediction_metadata</span><span class="p">[</span><span class="s2">&quot;video.path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">video_path</span>
    <span class="n">prediction_metadata</span><span class="p">[</span><span class="s2">&quot;sleap.version&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sleap</span><span class="o">.</span><span class="n">__version__</span>

    <span class="n">save_predictions_from_cli</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">predicted_frames</span><span class="p">,</span> <span class="n">prediction_metadata</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total Time: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">SLEAP</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/index.html">Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/reference.html">Feature Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019–2020, Murthy Lab @ Princeton.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>