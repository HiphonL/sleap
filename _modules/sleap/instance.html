
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>sleap.instance &#8212; SLEAP  documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for sleap.instance</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Data structures for all labeled data contained with a SLEAP project.</span>

<span class="sd">The relationships between objects in this module:</span>

<span class="sd">* A `LabeledFrame` can contain zero or more `Instance`s</span>
<span class="sd">  (and `PredictedInstance` objects).</span>

<span class="sd">* `Instance` objects (and `PredictedInstance` objects) have `PointArray`</span>
<span class="sd">  (or `PredictedPointArray`).</span>

<span class="sd">* `Instance` (`PredictedInstance`) can be associated with a `Track`</span>

<span class="sd">* A `PointArray` (or `PredictedPointArray`) contains zero or more</span>
<span class="sd">  `Point` objects (or `PredictedPoint` objectss), ideally as many as</span>
<span class="sd">  there are in the associated :class:`Skeleton` although these can get</span>
<span class="sd">  out of sync if the skeleton is manipulated.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cattr</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">from</span> <span class="nn">numpy.lib.recfunctions</span> <span class="kn">import</span> <span class="n">structured_to_unstructured</span>

<span class="kn">from</span> <span class="nn">sleap.skeleton</span> <span class="kn">import</span> <span class="n">Skeleton</span><span class="p">,</span> <span class="n">Node</span>
<span class="kn">from</span> <span class="nn">sleap.io.video</span> <span class="kn">import</span> <span class="n">Video</span>

<span class="kn">import</span> <span class="nn">attr</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">ForwardRef</span>
<span class="k">except</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">_ForwardRef</span> <span class="k">as</span> <span class="n">ForwardRef</span>


<div class="viewcode-block" id="Point"><a class="viewcode-back" href="../../instance.html#sleap.instance.Point">[docs]</a><span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">record</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A labelled point and any metadata associated with it.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: The horizontal pixel location of point within image frame.</span>
<span class="sd">        y: The vertical pixel location of point within image frame.</span>
<span class="sd">        visible: Whether point is visible in the labelled image or not.</span>
<span class="sd">        complete: Has the point been verified by the user labeler.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define the dtype from the point class attributes plus some</span>
    <span class="c1"># additional fields we will use to relate point to instances and</span>
    <span class="c1"># nodes.</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;f8&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;f8&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;visible&quot;</span><span class="p">,</span> <span class="s2">&quot;?&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;complete&quot;</span><span class="p">,</span> <span class="s2">&quot;?&quot;</span><span class="p">)])</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">visible</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">complete</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Point&quot;</span><span class="p">:</span>

        <span class="c1"># HACK: This is a crazy way to instantiate at new Point but I can&#39;t figure</span>
        <span class="c1"># out how recarray does it. So I just use it to make matrix of size 1 and</span>
        <span class="c1"># index in to get the np.record/Point</span>
        <span class="c1"># All of this is a giant hack so that Point(x=2,y=3) works like expected.</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">PointArray</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">visible</span><span class="p">,</span> <span class="n">complete</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># val.x = x</span>
        <span class="c1"># val.y = y</span>
        <span class="c1"># val.visible = visible</span>
        <span class="c1"># val.complete = complete</span>

        <span class="k">return</span> <span class="n">val</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{self.x}</span><span class="s2">, </span><span class="si">{self.y}</span><span class="s2">)&quot;</span>

<div class="viewcode-block" id="Point.isnan"><a class="viewcode-back" href="../../instance.html#sleap.instance.Point.isnan">[docs]</a>    <span class="k">def</span> <span class="nf">isnan</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Are either of the coordinates a NaN value.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if x or y is NaN, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span></div></div>


<span class="c1"># This turns PredictedPoint into an attrs class. Defines comparators for</span>
<span class="c1"># us and generaly makes it behave better. Crazy that this works!</span>
<span class="n">Point</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">these</span><span class="o">=</span><span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">Point</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">},</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)(</span><span class="n">Point</span><span class="p">)</span>


<div class="viewcode-block" id="PredictedPoint"><a class="viewcode-back" href="../../instance.html#sleap.instance.PredictedPoint">[docs]</a><span class="k">class</span> <span class="nc">PredictedPoint</span><span class="p">(</span><span class="n">Point</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A predicted point is an output of the inference procedure.</span>

<span class="sd">    It has all the properties of a labeled point, plus a score.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: The horizontal pixel location of point within image frame.</span>
<span class="sd">        y: The vertical pixel location of point within image frame.</span>
<span class="sd">        visible: Whether point is visible in the labelled image or not.</span>
<span class="sd">        complete: Has the point been verified by the user labeler.</span>
<span class="sd">        score: The point-level prediction score.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define the dtype from the point class attributes plus some</span>
    <span class="c1"># additional fields we will use to relate point to instances and</span>
    <span class="c1"># nodes.</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span>
        <span class="p">[(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;f8&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;f8&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;visible&quot;</span><span class="p">,</span> <span class="s2">&quot;?&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;complete&quot;</span><span class="p">,</span> <span class="s2">&quot;?&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;score&quot;</span><span class="p">,</span> <span class="s2">&quot;f8&quot;</span><span class="p">)]</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">visible</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">complete</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">score</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;PredictedPoint&quot;</span><span class="p">:</span>

        <span class="c1"># HACK: This is a crazy way to instantiate at new Point but I can&#39;t figure</span>
        <span class="c1"># out how recarray does it. So I just use it to make matrix of size 1 and</span>
        <span class="c1"># index in to get the np.record/Point</span>
        <span class="c1"># All of this is a giant hack so that Point(x=2,y=3) works like expected.</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">PredictedPointArray</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">visible</span><span class="p">,</span> <span class="n">complete</span><span class="p">,</span> <span class="n">score</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># val.x = x</span>
        <span class="c1"># val.y = y</span>
        <span class="c1"># val.visible = visible</span>
        <span class="c1"># val.complete = complete</span>
        <span class="c1"># val.score = score</span>

        <span class="k">return</span> <span class="n">val</span>

<div class="viewcode-block" id="PredictedPoint.from_point"><a class="viewcode-back" href="../../instance.html#sleap.instance.PredictedPoint.from_point">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_point</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">point</span><span class="p">:</span> <span class="n">Point</span><span class="p">,</span> <span class="n">score</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;PredictedPoint&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a PredictedPoint from a Point</span>

<span class="sd">        Args:</span>
<span class="sd">            point: The point to copy all data from.</span>
<span class="sd">            score: The score for this predicted point.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A scored point based on the point passed in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="o">**</span><span class="n">Point</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span><span class="n">point</span><span class="p">),</span> <span class="s2">&quot;score&quot;</span><span class="p">:</span> <span class="n">score</span><span class="p">})</span></div></div>


<span class="c1"># This turns PredictedPoint into an attrs class. Defines comparators for</span>
<span class="c1"># us and generaly makes it behave better. Crazy that this works!</span>
<span class="n">PredictedPoint</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span>
    <span class="n">these</span><span class="o">=</span><span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">PredictedPoint</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">},</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)(</span><span class="n">PredictedPoint</span><span class="p">)</span>


<div class="viewcode-block" id="PointArray"><a class="viewcode-back" href="../../instance.html#sleap.instance.PointArray">[docs]</a><span class="k">class</span> <span class="nc">PointArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PointArray is a sub-class of numpy recarray which stores</span>
<span class="sd">    Point objects as records.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_record_type</span> <span class="o">=</span> <span class="n">Point</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span>
        <span class="n">subtype</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">,</span>
        <span class="n">buf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">strides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">formats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">titles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">byteorder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aligned</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;PointArray&quot;</span><span class="p">:</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="n">subtype</span><span class="o">.</span><span class="n">_record_type</span><span class="o">.</span><span class="n">dtype</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">descr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">descr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">format_parser</span><span class="p">(</span><span class="n">formats</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">titles</span><span class="p">,</span> <span class="n">aligned</span><span class="p">,</span> <span class="n">byteorder</span><span class="p">)</span><span class="o">.</span><span class="n">_descr</span>

        <span class="k">if</span> <span class="n">buf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span>
                <span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="n">subtype</span><span class="o">.</span><span class="n">_record_type</span><span class="p">,</span> <span class="n">descr</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span>
                <span class="n">subtype</span><span class="p">,</span>
                <span class="n">shape</span><span class="p">,</span>
                <span class="p">(</span><span class="n">subtype</span><span class="o">.</span><span class="n">_record_type</span><span class="p">,</span> <span class="n">descr</span><span class="p">),</span>
                <span class="n">buffer</span><span class="o">=</span><span class="n">buf</span><span class="p">,</span>
                <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">,</span>
                <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Override :method:`np.recarray.__array_finalize__()`.</span>

<span class="sd">        Overide __array_finalize__ on recarray because it converting the</span>
<span class="sd">        dtype of any np.void subclass to np.record, we don&#39;t want this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="PointArray.make_default"><a class="viewcode-back" href="../../instance.html#sleap.instance.PointArray.make_default">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">make_default</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;PointArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a point array where points are all set to default.</span>

<span class="sd">        The constructed :class:`PointArray` will have specified size</span>
<span class="sd">        and each value in the array is assigned the default values for</span>
<span class="sd">        a :class:`Point``.</span>

<span class="sd">        Args:</span>
<span class="sd">            size: The number of points to allocate.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A point array with all elements set to Point()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">p</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_record_type</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">p</span></div>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Point&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get point by its index in the array.&quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span>

        <span class="c1"># copy behavior of getattr, except that here</span>
        <span class="c1"># we might also be returning a single element</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                <span class="c1"># if issubclass(obj.dtype.type, numpy.void):</span>
                <span class="c1">#    return obj.view(dtype=(self.dtype.type, obj.dtype))</span>
                <span class="k">return</span> <span class="n">obj</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># return a single element</span>
            <span class="k">return</span> <span class="n">obj</span>

<div class="viewcode-block" id="PointArray.from_array"><a class="viewcode-back" href="../../instance.html#sleap.instance.PointArray.from_array">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_array</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="s2">&quot;PointArray&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;PointArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a :class:`PointArray` (or child) to a new instance.</span>

<span class="sd">        This will convert an object to the same type as itself,</span>
<span class="sd">        so a :class:`PredictedPointArray` will result in the same.</span>

<span class="sd">        Uses the default attribute values for new array.</span>

<span class="sd">        Args:</span>
<span class="sd">            a: The array to convert.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A :class:`PointArray` or :class:`PredictedPointArray` with</span>
<span class="sd">            the same points as a.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">make_default</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">Point</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">v</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">v</span></div></div>


<div class="viewcode-block" id="PredictedPointArray"><a class="viewcode-back" href="../../instance.html#sleap.instance.PredictedPointArray">[docs]</a><span class="k">class</span> <span class="nc">PredictedPointArray</span><span class="p">(</span><span class="n">PointArray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PredictedPointArray is analogous to PointArray except for predicted</span>
<span class="sd">    points.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_record_type</span> <span class="o">=</span> <span class="n">PredictedPoint</span>

<div class="viewcode-block" id="PredictedPointArray.to_array"><a class="viewcode-back" href="../../instance.html#sleap.instance.PredictedPointArray.to_array">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">to_array</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="s2">&quot;PredictedPointArray&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;PointArray&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a PredictedPointArray to a normal PointArray.</span>

<span class="sd">        Args:</span>
<span class="sd">            a: The array to convert.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The converted array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">PointArray</span><span class="o">.</span><span class="n">make_default</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">Point</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">v</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">v</span></div></div>


<div class="viewcode-block" id="Track"><a class="viewcode-back" href="../../instance.html#sleap.instance.Track">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">slots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">cmp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Track</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A track object is associated with a set of animal/object instances</span>
<span class="sd">    across multiple frames of video. This allows tracking of unique</span>
<span class="sd">    entities in the video over time and space.</span>

<span class="sd">    Args:</span>
<span class="sd">        spawned_on: The video frame that this track was spawned on.</span>
<span class="sd">        name: A name given to this track for identifying purposes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">spawned_on</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">converter</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">converter</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>

<div class="viewcode-block" id="Track.matches"><a class="viewcode-back" href="../../instance.html#sleap.instance.Track.matches">[docs]</a>    <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Track&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if two tracks match by value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The other track to check</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if they match, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">attr</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">attr</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div></div>


<span class="c1"># NOTE:</span>
<span class="c1"># Instance cannot be a slotted class at the moment. This is because it creates</span>
<span class="c1"># attributes _frame and _point_array_cache after init. These are private variables</span>
<span class="c1"># that are created in post init so they are not serialized.</span>


<div class="viewcode-block" id="Instance"><a class="viewcode-back" href="../../instance.html#sleap.instance.Instance">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="nb">cmp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">slots</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Instance</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The class :class:`Instance` represents a labelled instance of a skeleton.</span>

<span class="sd">    Args:</span>
<span class="sd">        skeleton: The skeleton that this instance is associated with.</span>
<span class="sd">        points: A dictionary where keys are skeleton node names and</span>
<span class="sd">            values are Point objects. Alternatively, a point array whose</span>
<span class="sd">            length and order matches skeleton.nodes.</span>
<span class="sd">        track: An optional multi-frame object track associated with</span>
<span class="sd">            this instance. This allows individual animals/objects to be</span>
<span class="sd">            tracked across frames.</span>
<span class="sd">        from_predicted: The predicted instance (if any) that this was</span>
<span class="sd">            copied from.</span>
<span class="sd">        frame: A back reference to the :class:`LabeledFrame` that this</span>
<span class="sd">            :class:`Instance` belongs to. This field is set when</span>
<span class="sd">            instances are added to :class:`LabeledFrame` objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">skeleton</span><span class="p">:</span> <span class="n">Skeleton</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="n">track</span><span class="p">:</span> <span class="n">Track</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">from_predicted</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;PredictedInstance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">_points</span><span class="p">:</span> <span class="n">PointArray</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">_nodes</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">frame</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;LabeledFrame&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># The underlying Point array type that this instances point array should be.</span>
    <span class="n">_point_array_type</span> <span class="o">=</span> <span class="n">PointArray</span>

    <span class="nd">@from_predicted</span><span class="o">.</span><span class="n">validator</span>
    <span class="k">def</span> <span class="nf">_validate_from_predicted_</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">from_predicted</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;PredictedInstance&quot;</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validation method called by attrs.</span>

<span class="sd">        Checks that from_predicted is None or :class:`PredictedInstance`</span>

<span class="sd">        Args:</span>
<span class="sd">            attribute: Attribute being validated; not used.</span>
<span class="sd">            from_predicted: Value being validated.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If from_predicted is anything other than None</span>
<span class="sd">                or a `PredictedInstance`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">from_predicted</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">from_predicted</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PredictedInstance</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Instance.from_predicted type must be PredictedInstance (not {type(from_predicted)})&quot;</span>
            <span class="p">)</span>

    <span class="nd">@_points</span><span class="o">.</span><span class="n">validator</span>
    <span class="k">def</span> <span class="nf">_validate_all_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="n">PointArray</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validation method called by attrs.</span>

<span class="sd">        Checks that all the _points defined for the skeleton are found</span>
<span class="sd">        in the skeleton.</span>

<span class="sd">        Args:</span>
<span class="sd">            attribute: Attribute being validated; not used.</span>
<span class="sd">            points: Either dict of points or PointArray</span>
<span class="sd">                If dict, keys should be node names.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If a point is associated with a skeleton node</span>
<span class="sd">                name that doesn&#39;t exist.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">is_string_dict</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">points</span><span class="p">))</span> <span class="o">==</span> <span class="p">{</span><span class="nb">str</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">is_string_dict</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">node_name</span> <span class="ow">in</span> <span class="n">points</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">node_name</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;There is no node named </span><span class="si">{node_name}</span><span class="s2"> in </span><span class="si">{self.skeleton}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">PointArray</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;PointArray does not have the same number of rows as skeleton nodes.&quot;</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method called by attrs after __init__()</span>

<span class="sd">        Initializes points if none were specified when creating object,</span>
<span class="sd">        caches list of nodes so what we can still find points in array</span>
<span class="sd">        if the `Skeleton` changes.</span>

<span class="sd">        Args:</span>
<span class="sd">            None</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If object has no `Skeleton`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No skeleton set for Instance&quot;</span><span class="p">)</span>

        <span class="c1"># If the user did not pass a points list initialize a point array for future</span>
        <span class="c1"># points.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># Initialize an empty point array that is the size of the skeleton.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_array_type</span><span class="o">.</span><span class="n">make_default</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="n">parray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_array_type</span><span class="o">.</span><span class="n">make_default</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
                <span class="n">Instance</span><span class="o">.</span><span class="n">_points_dict_to_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">,</span> <span class="n">parray</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">parray</span>

        <span class="c1"># Now that we&#39;ve validated the points, cache the list of nodes</span>
        <span class="c1"># in the skeleton since the PointArray indexing will be linked</span>
        <span class="c1"># to this list even if nodes are removed from the skeleton.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="o">.</span><span class="n">nodes</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_points_dict_to_array</span><span class="p">(</span>
        <span class="n">points</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Node</span><span class="p">],</span> <span class="n">Point</span><span class="p">],</span> <span class="n">parray</span><span class="p">:</span> <span class="n">PointArray</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">:</span> <span class="n">Skeleton</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets values in given :class:`PointsArray` from dictionary.</span>

<span class="sd">        Args:</span>
<span class="sd">            points: The dictionary of points. Keys can be either node</span>
<span class="sd">                names or :class:`Node`s, values are :class:`Point`s.</span>
<span class="sd">            parray: The :class:`PointsArray` which is being updated.</span>
<span class="sd">            skeleton: The :class:`Skeleton` which contains the nodes</span>
<span class="sd">                referenced in the dictionary of points.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If dictionary keys are not either all strings</span>
<span class="sd">                or all :class:`Node`s.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check if the dict contains all strings</span>
        <span class="n">is_string_dict</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">points</span><span class="p">))</span> <span class="o">==</span> <span class="p">{</span><span class="nb">str</span><span class="p">}</span>

        <span class="c1"># Check if the dict contains all Node objects</span>
        <span class="n">is_node_dict</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">points</span><span class="p">))</span> <span class="o">==</span> <span class="p">{</span><span class="n">Node</span><span class="p">}</span>

        <span class="c1"># If the user fed in a dict whose keys are strings, these are node names,</span>
        <span class="c1"># convert to node indices so we don&#39;t break references to skeleton nodes</span>
        <span class="c1"># if the node name is relabeled.</span>
        <span class="k">if</span> <span class="n">points</span> <span class="ow">and</span> <span class="n">is_string_dict</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="p">{</span><span class="n">skeleton</span><span class="o">.</span><span class="n">find_node</span><span class="p">(</span><span class="n">name</span><span class="p">):</span> <span class="n">point</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_string_dict</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_node_dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;points dictionary must be keyed by either strings &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;(node names) or Nodes.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Get rid of the points dict and replace with equivalent point array.</span>
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Convert PredictedPoint to Point if Instance</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">parray</span><span class="p">)</span> <span class="o">==</span> <span class="n">PointArray</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">==</span> <span class="n">PredictedPoint</span><span class="p">:</span>
                <span class="n">point</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span>
                    <span class="n">x</span><span class="o">=</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">visible</span><span class="o">=</span><span class="n">point</span><span class="o">.</span><span class="n">visible</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="n">point</span><span class="o">.</span><span class="n">complete</span>
                <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">parray</span><span class="p">[</span><span class="n">skeleton</span><span class="o">.</span><span class="n">node_to_index</span><span class="p">(</span><span class="n">node</span><span class="p">)]</span> <span class="o">=</span> <span class="n">point</span>
                <span class="c1"># parray[skeleton.node_to_index(node.name)] = point</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_node_to_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Node</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to get the index of a node from its name.</span>

<span class="sd">        Args:</span>
<span class="sd">            node: Node name or :class:`Node` object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The index of the node on skeleton graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="o">.</span><span class="n">node_to_index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Node</span><span class="p">]],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Node</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Point</span><span class="p">],</span> <span class="n">Point</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the Points associated with particular skeleton node(s).</span>

<span class="sd">        Args:</span>
<span class="sd">            node: A single node or list of nodes within the skeleton</span>
<span class="sd">                associated with this instance.</span>

<span class="sd">        Raises:</span>
<span class="sd">            KeyError: If node cannot be found in skeleton.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Either a single point (if a single node given), or</span>
<span class="sd">            a list of points (if a list of nodes given) corresponding</span>
<span class="sd">            to each node.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If the node is a list of nodes, use get item recursively and return a list of _points.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">ret_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                <span class="n">ret_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">ret_list</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_to_index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The underlying skeleton (</span><span class="si">{self.skeleton}</span><span class="s2">) has no node &#39;</span><span class="si">{node}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Node</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether this instance has a point with the specified node.</span>

<span class="sd">        Args:</span>
<span class="sd">            node: Node name or :class:`Node` object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the point with the node name specified has a</span>
<span class="sd">                point in this instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">node_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_to_index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># If the points are nan, then they haven&#39;t been allocated.</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="n">node_idx</span><span class="p">]</span><span class="o">.</span><span class="n">isnan</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Node</span><span class="p">]],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Node</span><span class="p">]],</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Point</span><span class="p">],</span> <span class="n">Point</span><span class="p">],</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the point(s) for given node(s).</span>

<span class="sd">        Args:</span>
<span class="sd">            node: Either node (by name or `Node`) or list of nodes.</span>
<span class="sd">            value: Either `Point` or list of `Point`s.</span>

<span class="sd">        Raises:</span>
<span class="sd">            IndexError: If lengths of lists don&#39;t match, or if exactly</span>
<span class="sd">                one of the inputs is a list.</span>
<span class="sd">            KeyError: If skeleton does not have (one of) the node(s).</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Make sure node and value, if either are lists, are of compatible size</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;Node list for indexing must be same length and value list.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;Node list for indexing must be same length and value list.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># If we are dealing with lists, do multiple assignment recursively, this should be ok because</span>
        <span class="c1"># skeletons and instances are small.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">node_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_to_index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="n">node_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The underlying skeleton (</span><span class="si">{self.skeleton}</span><span class="s2">) has no node &#39;</span><span class="si">{node}</span><span class="s2">&#39;&quot;</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Node</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete node key and points associated with that node.</span>

<span class="sd">        Args:</span>
<span class="sd">            node: Node name or :class:`Node` object.</span>

<span class="sd">        Raises:</span>
<span class="sd">            KeyError: If skeleton does not have the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">node_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_to_index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="n">node_idx</span><span class="p">]</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="n">node_idx</span><span class="p">]</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The underlying skeleton (</span><span class="si">{self.skeleton}</span><span class="s2">) has no node &#39;</span><span class="si">{node}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="Instance.matches"><a class="viewcode-back" href="../../instance.html#sleap.instance.Instance.matches">[docs]</a>    <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Instance&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether two instances match by value.</span>

<span class="sd">        Checks the types, points, track, and frame index.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The other :class:`Instance`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if match, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">skeleton</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">track</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">track</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">track</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">track</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">track</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">track</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">track</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Make sure the frame indices match</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_idx</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">frame_idx</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The tuple of nodes that have been labelled for this instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fix_array</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">point</span><span class="o">.</span><span class="n">isnan</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="o">.</span><span class="n">nodes</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nodes_points</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="n">Point</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The list of (node, point) tuples for all labelled points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">names_to_points</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">names_to_points</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">points</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Point</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The tuple of labelled points, in order they were labelled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fix_array</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">point</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">point</span><span class="o">.</span><span class="n">isnan</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_fix_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fixes PointArray after nodes have been added or removed.</span>

<span class="sd">        This updates the PointArray as required by comparing the cached</span>
<span class="sd">        list of nodes to the nodes in the `Skeleton` object (which may</span>
<span class="sd">        have changed).</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check if cached skeleton nodes are different than current nodes</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="c1"># Create new PointArray (or PredictedPointArray)</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">)</span>
            <span class="n">new_array</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">make_default</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>

            <span class="c1"># Add points into new array</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                    <span class="n">new_array</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Update points and nodes for this instance</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">new_array</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="o">.</span><span class="n">nodes</span>

<div class="viewcode-block" id="Instance.get_points_array"><a class="viewcode-back" href="../../instance.html#sleap.instance.Instance.get_points_array">[docs]</a>    <span class="k">def</span> <span class="nf">get_points_array</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">invisible_as_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">full</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the instance&#39;s points in array form.</span>

<span class="sd">        Args:</span>
<span class="sd">            copy: If True, the return a copy of the points array as an</span>
<span class="sd">                Nx2 ndarray where first column is x and second is y.</span>
<span class="sd">                If False, return a view of the underlying recarray.</span>
<span class="sd">            invisible_as_nan: Should invisible points be marked as NaN.</span>
<span class="sd">            full: If True, return the raw underlying recarray with all</span>
<span class="sd">                attributes of the point.</span>
<span class="sd">                Otherwise, return just the x and y coordinate.</span>
<span class="sd">                Assumes copy is False and invisible_as_nan is False.</span>
<span class="sd">        Returns:</span>
<span class="sd">            A Nx2 array containing x and y coordinates of each point</span>
<span class="sd">            as the rows of the array and N is the number of nodes in the</span>
<span class="sd">            skeleton. The order of the rows corresponds to the ordering</span>
<span class="sd">            of the skeleton nodes. Any skeleton node not defined will</span>
<span class="sd">            have NaNs present.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fix_array</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">invisible_as_nan</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parray</span> <span class="o">=</span> <span class="n">structured_to_unstructured</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">]])</span>

            <span class="k">if</span> <span class="n">invisible_as_nan</span><span class="p">:</span>
                <span class="n">parray</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">visible</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>

            <span class="k">return</span> <span class="n">parray</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">points_array</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Nx2 array of x and y for visible points.</span>

<span class="sd">        Row in arrow corresponds to order of points in skeleton.</span>
<span class="sd">        Invisible points will have nans.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ndarray of visible point coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points_array</span><span class="p">(</span><span class="n">invisible_as_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns instance centroid as (x,y) numpy row vector.&quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points_array</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">centroid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the instance&#39;s containing bounding box in [y1, x1, y2, x2] format.&quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points_array</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">bbox</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_visible_points</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the count of points that are visible in this instance.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">frame_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the index of the frame that this instance was found on.</span>

<span class="sd">        This is a convenience method for Instance.frame.frame_idx.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The frame number this instance was found on, or None if the</span>
<span class="sd">            instance is not associated with frame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">frame_idx</span></div>


<div class="viewcode-block" id="PredictedInstance"><a class="viewcode-back" href="../../instance.html#sleap.instance.PredictedInstance">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="nb">cmp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">slots</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">PredictedInstance</span><span class="p">(</span><span class="n">Instance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A predicted instance is an output of the inference procedure.</span>

<span class="sd">    Args:</span>
<span class="sd">        score: The instance-level grouping prediction score.</span>
<span class="sd">        tracking_score: The instance-level track matching score.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">score</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">converter</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">tracking_score</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">converter</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># The underlying Point array type that this instances point array should be.</span>
    <span class="n">_point_array_type</span> <span class="o">=</span> <span class="n">PredictedPointArray</span>

    <span class="k">def</span> <span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PredictedInstance</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__attrs_post_init__</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_predicted</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;PredictedInstance should not have from_predicted.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="PredictedInstance.from_instance"><a class="viewcode-back" href="../../instance.html#sleap.instance.PredictedInstance.from_instance">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_instance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="n">Instance</span><span class="p">,</span> <span class="n">score</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a :class:`PredictedInstance` from an :class:`Instance`.</span>

<span class="sd">        The fields are copied in a shallow manner with the exception of</span>
<span class="sd">        points. For each point in the instance a :class:`PredictedPoint`</span>
<span class="sd">        is created with score set to default value.</span>

<span class="sd">        Args:</span>
<span class="sd">            instance: The Instance object to shallow copy data from.</span>
<span class="sd">            score: The score for this instance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A PredictedInstance for the given Instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kw_args</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span>
            <span class="n">instance</span><span class="p">,</span>
            <span class="n">recurse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="nb">filter</span><span class="o">=</span><span class="k">lambda</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">attr</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;_points&quot;</span><span class="p">,</span> <span class="s2">&quot;_nodes&quot;</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">kw_args</span><span class="p">[</span><span class="s2">&quot;points&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">PredictedPointArray</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">_points</span><span class="p">)</span>
        <span class="n">kw_args</span><span class="p">[</span><span class="s2">&quot;score&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">score</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">kw_args</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="make_instance_cattr"><a class="viewcode-back" href="../../instance.html#sleap.instance.make_instance_cattr">[docs]</a><span class="k">def</span> <span class="nf">make_instance_cattr</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">cattr</span><span class="o">.</span><span class="n">Converter</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a cattr converter for Lists of Instances/PredictedInstances.</span>

<span class="sd">    This is required because cattrs doesn&#39;t automatically detect the</span>
<span class="sd">    class when the attributes of one class are a subset of another.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A cattr converter with hooks registered for structuring and</span>
<span class="sd">            unstructuring :class:`Instance` objects and</span>
<span class="sd">            :class:`PredictedInstance`s.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">converter</span> <span class="o">=</span> <span class="n">cattr</span><span class="o">.</span><span class="n">Converter</span><span class="p">()</span>

    <span class="c1">#### UNSTRUCTURE HOOKS</span>

    <span class="c1"># JSON dump cant handle NumPy bools so convert them. These are present</span>
    <span class="c1"># in Point/PredictedPoint objects now since they are actually custom numpy dtypes.</span>
    <span class="n">converter</span><span class="o">.</span><span class="n">register_unstructure_hook</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

    <span class="n">converter</span><span class="o">.</span><span class="n">register_unstructure_hook</span><span class="p">(</span><span class="n">PointArray</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">converter</span><span class="o">.</span><span class="n">register_unstructure_hook</span><span class="p">(</span><span class="n">PredictedPointArray</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unstructure_instance</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Instance</span><span class="p">):</span>

        <span class="c1"># Unstructure everything but the points array, nodes, and frame attribute</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">converter</span><span class="o">.</span><span class="n">unstructure</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">attr</span><span class="o">.</span><span class="n">fields</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;_points&quot;</span><span class="p">,</span> <span class="s2">&quot;_nodes&quot;</span><span class="p">,</span> <span class="s2">&quot;frame&quot;</span><span class="p">]</span>
        <span class="p">}</span>

        <span class="c1"># Replace the point array with a dict</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;_points&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">unstructure</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">nodes_points</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">d</span>

    <span class="n">converter</span><span class="o">.</span><span class="n">register_unstructure_hook</span><span class="p">(</span><span class="n">Instance</span><span class="p">,</span> <span class="n">unstructure_instance</span><span class="p">)</span>
    <span class="n">converter</span><span class="o">.</span><span class="n">register_unstructure_hook</span><span class="p">(</span><span class="n">PredictedInstance</span><span class="p">,</span> <span class="n">unstructure_instance</span><span class="p">)</span>

    <span class="c1">## STRUCTURE HOOKS</span>

    <span class="k">def</span> <span class="nf">structure_points</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;score&quot;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">cattr</span><span class="o">.</span><span class="n">structure</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">PredictedPoint</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cattr</span><span class="o">.</span><span class="n">structure</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Point</span><span class="p">)</span>

    <span class="n">converter</span><span class="o">.</span><span class="n">register_structure_hook</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="n">Point</span><span class="p">,</span> <span class="n">PredictedPoint</span><span class="p">],</span> <span class="n">structure_points</span><span class="p">)</span>

    <span class="c1"># Function to determine object type for objects being structured.</span>
    <span class="k">def</span> <span class="nf">structure_instances_list</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="n">inst_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">inst_data</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;score&quot;</span> <span class="ow">in</span> <span class="n">inst_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">inst</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">structure</span><span class="p">(</span><span class="n">inst_data</span><span class="p">,</span> <span class="n">PredictedInstance</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inst</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">structure</span><span class="p">(</span><span class="n">inst_data</span><span class="p">,</span> <span class="n">Instance</span><span class="p">)</span>
            <span class="n">inst_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">inst_list</span>

    <span class="n">converter</span><span class="o">.</span><span class="n">register_structure_hook</span><span class="p">(</span>
        <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Instance</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">PredictedInstance</span><span class="p">]],</span> <span class="n">structure_instances_list</span>
    <span class="p">)</span>

    <span class="n">converter</span><span class="o">.</span><span class="n">register_structure_hook</span><span class="p">(</span>
        <span class="n">ForwardRef</span><span class="p">(</span><span class="s2">&quot;PredictedInstance&quot;</span><span class="p">),</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="n">converter</span><span class="o">.</span><span class="n">structure</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">PredictedInstance</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="c1"># We can register structure hooks for point arrays that do nothing</span>
    <span class="c1"># because Instance can have a dict of points passed to it in place of</span>
    <span class="c1"># a PointArray</span>
    <span class="k">def</span> <span class="nf">structure_point_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">point1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="s2">&quot;score&quot;</span> <span class="ow">in</span> <span class="n">point1</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">converter</span><span class="o">.</span><span class="n">structure</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="n">PredictedPoint</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">converter</span><span class="o">.</span><span class="n">structure</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Node</span><span class="p">,</span> <span class="n">Point</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>

    <span class="n">converter</span><span class="o">.</span><span class="n">register_structure_hook</span><span class="p">(</span><span class="n">PointArray</span><span class="p">,</span> <span class="n">structure_point_array</span><span class="p">)</span>
    <span class="n">converter</span><span class="o">.</span><span class="n">register_structure_hook</span><span class="p">(</span><span class="n">PredictedPointArray</span><span class="p">,</span> <span class="n">structure_point_array</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">converter</span></div>


<div class="viewcode-block" id="LabeledFrame"><a class="viewcode-back" href="../../instance.html#sleap.instance.LabeledFrame">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">auto_attribs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">LabeledFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Holds labeled data for a single frame of a video.</span>

<span class="sd">    Args:</span>
<span class="sd">        video: The :class:`Video` associated with this frame.</span>
<span class="sd">        frame_idx: The index of frame in video.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">video</span><span class="p">:</span> <span class="n">Video</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="n">frame_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">converter</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">_instances</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Instance</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">PredictedInstance</span><span class="p">]]</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="n">attr</span><span class="o">.</span><span class="n">Factory</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by attrs.</span>

<span class="sd">        Updates :attribute:`Instance.frame` for each instance associated</span>
<span class="sd">        with this :class:`LabeledFrame`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Make sure all instances have a reference to this frame</span>
        <span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="p">:</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of instances associated with frame.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Instance</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns instance (retrieved by index).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

<div class="viewcode-block" id="LabeledFrame.index"><a class="viewcode-back" href="../../instance.html#sleap.instance.LabeledFrame.index">[docs]</a>    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Instance</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns index of given :class:`Instance`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes instance (by index) from frame.&quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># Modify the instance to remove reference to this frame</span>
        <span class="n">value</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="LabeledFrame.insert"><a class="viewcode-back" href="../../instance.html#sleap.instance.LabeledFrame.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Instance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds instance to frame.</span>

<span class="sd">        Args:</span>
<span class="sd">            index: The index in list of frame instances where we should</span>
<span class="sd">                insert the new instance.</span>
<span class="sd">            value: The instance to associate with frame.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># Modify the instance to have a reference back to this frame</span>
        <span class="n">value</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Instance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets nth instance in frame to the given instance.</span>

<span class="sd">        Args:</span>
<span class="sd">            index: The index of instance to replace with new instance.</span>
<span class="sd">            value: The new instance to associate with frame.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># Modify the instance to have a reference back to this frame</span>
        <span class="n">value</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span>

<div class="viewcode-block" id="LabeledFrame.find"><a class="viewcode-back" href="../../instance.html#sleap.instance.LabeledFrame.find">[docs]</a>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">track</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Track</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">user</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Instance</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves instances (if any) matching specifications.</span>

<span class="sd">        Args:</span>
<span class="sd">            track: The :class:`Track` to match. Note that None will only</span>
<span class="sd">                match instances where :attribute:`Instance.track` is</span>
<span class="sd">                None. If track is -1, then we&#39;ll match any track.</span>
<span class="sd">            user: Whether to only match user (non-predicted) instances.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">instances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instances</span>
        <span class="k">if</span> <span class="n">user</span><span class="p">:</span>
            <span class="n">instances</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">inst</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span> <span class="o">==</span> <span class="n">Instance</span><span class="p">,</span> <span class="n">instances</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">track</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># use -1 since we want to accept None as possible value</span>
            <span class="n">instances</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">inst</span><span class="p">:</span> <span class="n">inst</span><span class="o">.</span><span class="n">track</span> <span class="o">==</span> <span class="n">track</span><span class="p">,</span> <span class="n">instances</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">instances</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">instances</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Instance</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns list of all instances associated with this frame.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instances</span>

    <span class="nd">@instances</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">instances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instances</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Instance</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the list of instances associated with this frame.</span>

<span class="sd">        Updates the `frame` attribute on each instance to the</span>
<span class="sd">        :class:`LabeledFrame` which will contain the instance.</span>
<span class="sd">        The list of instances replaces instances that were previously</span>
<span class="sd">        associated with frame.</span>

<span class="sd">        Args:</span>
<span class="sd">            instances: A list of instances associated with this frame.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Make sure to set the frame for each instance to this LabeledFrame</span>
        <span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">instances</span><span class="p">:</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_instances</span> <span class="o">=</span> <span class="n">instances</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">user_instances</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Instance</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns list of user instances associated with this frame.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">inst</span> <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instances</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">PredictedInstance</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">predicted_instances</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">PredictedInstance</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns list of predicted instances associated with frame.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">inst</span> <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instances</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">PredictedInstance</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_user_instances</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Whether the frame contains any user instances.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">user_instances</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_predicted_instances</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Whether the frame contains any predicted instances.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predicted_instances</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unused_predictions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Instance</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns list of &quot;unused&quot; :class:`PredictedInstance` objects in frame.</span>

<span class="sd">        This is all the :class:`PredictedInstance` objects which do not have</span>
<span class="sd">        a corresponding :class:`Instance` in the same track in frame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unused_predictions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">any_tracks</span> <span class="o">=</span> <span class="p">[</span><span class="n">inst</span><span class="o">.</span><span class="n">track</span> <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instances</span> <span class="k">if</span> <span class="n">inst</span><span class="o">.</span><span class="n">track</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">any_tracks</span><span class="p">):</span>
            <span class="c1"># use tracks to determine which predicted instances have been used</span>
            <span class="n">used_tracks</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">track</span>
                <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instances</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span> <span class="o">==</span> <span class="n">Instance</span> <span class="ow">and</span> <span class="n">inst</span><span class="o">.</span><span class="n">track</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">]</span>
            <span class="n">unused_predictions</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">inst</span>
                <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instances</span>
                <span class="k">if</span> <span class="n">inst</span><span class="o">.</span><span class="n">track</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">used_tracks</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span> <span class="o">==</span> <span class="n">PredictedInstance</span>
            <span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># use from_predicted to determine which predicted instances have been used</span>
            <span class="c1"># TODO: should we always do this instead of using tracks?</span>
            <span class="n">used_instances</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">from_predicted</span>
                <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instances</span>
                <span class="k">if</span> <span class="n">inst</span><span class="o">.</span><span class="n">from_predicted</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">]</span>
            <span class="n">unused_predictions</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">inst</span>
                <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instances</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span> <span class="o">==</span> <span class="n">PredictedInstance</span> <span class="ow">and</span> <span class="n">inst</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">used_instances</span>
            <span class="p">]</span>

        <span class="k">return</span> <span class="n">unused_predictions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">instances_to_show</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Instance</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of instances to show in GUI for this frame.</span>

<span class="sd">        This list will not include any predicted instances for which</span>
<span class="sd">        there&#39;s a corresponding regular instance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of instances to show in GUI.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unused_predictions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unused_predictions</span>
        <span class="n">inst_to_show</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">inst</span>
            <span class="k">for</span> <span class="n">inst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instances</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span> <span class="o">==</span> <span class="n">Instance</span> <span class="ow">or</span> <span class="n">inst</span> <span class="ow">in</span> <span class="n">unused_predictions</span>
        <span class="p">]</span>
        <span class="n">inst_to_show</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">inst</span><span class="p">:</span> <span class="n">inst</span><span class="o">.</span><span class="n">track</span><span class="o">.</span><span class="n">spawned_on</span>
            <span class="k">if</span> <span class="n">inst</span><span class="o">.</span><span class="n">track</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">inst_to_show</span>

<div class="viewcode-block" id="LabeledFrame.merge_frames"><a class="viewcode-back" href="../../instance.html#sleap.instance.LabeledFrame.merge_frames">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge_frames</span><span class="p">(</span>
        <span class="n">labeled_frames</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;LabeledFrame&quot;</span><span class="p">],</span> <span class="n">video</span><span class="p">:</span> <span class="s2">&quot;Video&quot;</span><span class="p">,</span> <span class="n">remove_redundant</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;LabeledFrame&quot;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Merged LabeledFrames for same video and frame index.</span>

<span class="sd">        Args:</span>
<span class="sd">            labeled_frames: List of :class:`LabeledFrame` objects to merge.</span>
<span class="sd">            video: The :class:`Video` for which to merge.</span>
<span class="sd">                This is specified so we don&#39;t have to check all frames when we</span>
<span class="sd">                already know which video has new labeled frames.</span>
<span class="sd">            remove_redundant: Whether to drop instances in the merged frames</span>
<span class="sd">                where there&#39;s a perfect match.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The merged list of :class:`LabeledFrame`s.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">redundant_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">frames_found</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># move instances into first frame with matching frame_idx</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">lf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labeled_frames</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">lf</span><span class="o">.</span><span class="n">video</span> <span class="o">==</span> <span class="n">video</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lf</span><span class="o">.</span><span class="n">frame_idx</span> <span class="ow">in</span> <span class="n">frames_found</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="c1"># move instances</span>
                    <span class="n">dst_idx</span> <span class="o">=</span> <span class="n">frames_found</span><span class="p">[</span><span class="n">lf</span><span class="o">.</span><span class="n">frame_idx</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">remove_redundant</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">new_inst</span> <span class="ow">in</span> <span class="n">lf</span><span class="o">.</span><span class="n">instances</span><span class="p">:</span>
                            <span class="n">redundant</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">for</span> <span class="n">old_inst</span> <span class="ow">in</span> <span class="n">labeled_frames</span><span class="p">[</span><span class="n">dst_idx</span><span class="p">]</span><span class="o">.</span><span class="n">instances</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">new_inst</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">old_inst</span><span class="p">):</span>
                                    <span class="n">redundant</span> <span class="o">=</span> <span class="kc">True</span>
                                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">new_inst</span><span class="p">,</span> <span class="s2">&quot;score&quot;</span><span class="p">):</span>
                                        <span class="n">redundant_count</span> <span class="o">+=</span> <span class="mi">1</span>
                                    <span class="k">break</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">redundant</span><span class="p">:</span>
                                <span class="n">labeled_frames</span><span class="p">[</span><span class="n">dst_idx</span><span class="p">]</span><span class="o">.</span><span class="n">instances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_inst</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">labeled_frames</span><span class="p">[</span><span class="n">dst_idx</span><span class="p">]</span><span class="o">.</span><span class="n">instances</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lf</span><span class="o">.</span><span class="n">instances</span><span class="p">)</span>
                    <span class="n">lf</span><span class="o">.</span><span class="n">instances</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># note first lf with this frame_idx</span>
                    <span class="n">frames_found</span><span class="p">[</span><span class="n">lf</span><span class="o">.</span><span class="n">frame_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="c1"># remove labeled frames with no instances</span>
        <span class="n">labeled_frames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">lf</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">lf</span><span class="o">.</span><span class="n">instances</span><span class="p">),</span> <span class="n">labeled_frames</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">redundant_count</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skipped </span><span class="si">{redundant_count}</span><span class="s2"> redundant instances&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">labeled_frames</span></div>

<div class="viewcode-block" id="LabeledFrame.complex_merge_between"><a class="viewcode-back" href="../../instance.html#sleap.instance.LabeledFrame.complex_merge_between">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">complex_merge_between</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">base_labels</span><span class="p">:</span> <span class="s2">&quot;Labels&quot;</span><span class="p">,</span> <span class="n">new_frames</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;LabeledFrame&quot;</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Video</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Instance</span><span class="p">]]],</span> <span class="n">List</span><span class="p">[</span><span class="n">Instance</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Instance</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge data from new frames into a :class:`Labels` object.</span>

<span class="sd">        Everything that can be merged cleanly is merged, any conflicts</span>
<span class="sd">        are returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            base_labels: The :class:`Labels` into which we are merging.</span>
<span class="sd">            new_frames: The list of :class:`LabeledFrame` objects from</span>
<span class="sd">                which we are merging.</span>
<span class="sd">        Returns:</span>
<span class="sd">            tuple of three items:</span>
<span class="sd">            * Dictionary, keys are :class:`Video`, values are</span>
<span class="sd">                dictionary in which keys are frame index (int)</span>
<span class="sd">                and value is list of :class:`Instance`s</span>
<span class="sd">            * list of conflicting :class:`Instance` objects from base</span>
<span class="sd">            * list of conflicting :class:`Instance` objects from new frames</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">extra_base</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">extra_new</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">new_frame</span> <span class="ow">in</span> <span class="n">new_frames</span><span class="p">:</span>
            <span class="n">base_lfs</span> <span class="o">=</span> <span class="n">base_labels</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">new_frame</span><span class="o">.</span><span class="n">video</span><span class="p">,</span> <span class="n">new_frame</span><span class="o">.</span><span class="n">frame_idx</span><span class="p">)</span>
            <span class="n">merged_instances</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># If the base doesn&#39;t have a frame corresponding this new</span>
            <span class="c1"># frame, then it can be merged cleanly.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">base_lfs</span><span class="p">:</span>
                <span class="n">base_labels</span><span class="o">.</span><span class="n">labeled_frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_frame</span><span class="p">)</span>
                <span class="n">merged_instances</span> <span class="o">=</span> <span class="n">new_frame</span><span class="o">.</span><span class="n">instances</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># There&#39;s a corresponding frame in the base labels,</span>
                <span class="c1"># so try merging the data.</span>
                <span class="p">(</span>
                    <span class="n">merged_instances</span><span class="p">,</span>
                    <span class="n">extra_base_frame</span><span class="p">,</span>
                    <span class="n">extra_new_frame</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">complex_frame_merge</span><span class="p">(</span><span class="n">base_lfs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_frame</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">extra_base_frame</span><span class="p">:</span>
                    <span class="n">extra_base</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">extra_base_frame</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">extra_new_frame</span><span class="p">:</span>
                    <span class="n">extra_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">extra_new_frame</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">merged_instances</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">new_frame</span><span class="o">.</span><span class="n">video</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">merged</span><span class="p">:</span>
                    <span class="n">merged</span><span class="p">[</span><span class="n">new_frame</span><span class="o">.</span><span class="n">video</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="n">merged</span><span class="p">[</span><span class="n">new_frame</span><span class="o">.</span><span class="n">video</span><span class="p">][</span><span class="n">new_frame</span><span class="o">.</span><span class="n">frame_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged_instances</span>
        <span class="k">return</span> <span class="n">merged</span><span class="p">,</span> <span class="n">extra_base</span><span class="p">,</span> <span class="n">extra_new</span></div>

<div class="viewcode-block" id="LabeledFrame.complex_frame_merge"><a class="viewcode-back" href="../../instance.html#sleap.instance.LabeledFrame.complex_frame_merge">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">complex_frame_merge</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">base_frame</span><span class="p">:</span> <span class="s2">&quot;LabeledFrame&quot;</span><span class="p">,</span> <span class="n">new_frame</span><span class="p">:</span> <span class="s2">&quot;LabeledFrame&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Instance</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Instance</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Instance</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge two frames, return conflicts if any.</span>

<span class="sd">        A conflict occurs when</span>
<span class="sd">        * each frame has Instances which don&#39;t perfectly match those</span>
<span class="sd">          in the other frame, or</span>
<span class="sd">        * each frame has PredictedInstances which don&#39;t perfectly match</span>
<span class="sd">          those in the other frame.</span>

<span class="sd">        Args:</span>
<span class="sd">            base_frame: The `LabeledFrame` into which we want to merge.</span>
<span class="sd">            new_frame: The `LabeledFrame` from which we want to merge.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple of three items:</span>
<span class="sd">            * list of instances that were merged</span>
<span class="sd">            * list of conflicting instances from base</span>
<span class="sd">            * list of conflicting instances from new</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">merged_instances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">redundant_instances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">extra_base_instances</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">base_frame</span><span class="o">.</span><span class="n">instances</span><span class="p">)</span>
        <span class="n">extra_new_instances</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">new_inst</span> <span class="ow">in</span> <span class="n">new_frame</span><span class="p">:</span>
            <span class="n">redundant</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">base_inst</span> <span class="ow">in</span> <span class="n">base_frame</span><span class="o">.</span><span class="n">instances</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">new_inst</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">base_inst</span><span class="p">):</span>
                    <span class="n">base_inst</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">extra_base_instances</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">base_inst</span><span class="p">)</span>
                    <span class="n">redundant_instances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">base_inst</span><span class="p">)</span>
                    <span class="n">redundant</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">redundant</span><span class="p">:</span>
                <span class="n">new_inst</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">extra_new_instances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_inst</span><span class="p">)</span>

        <span class="n">conflict</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">extra_base_instances</span> <span class="ow">and</span> <span class="n">extra_new_instances</span><span class="p">:</span>
            <span class="n">base_predictions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">inst</span><span class="p">:</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="s2">&quot;score&quot;</span><span class="p">),</span> <span class="n">extra_base_instances</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">new_predictions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">inst</span><span class="p">:</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="s2">&quot;score&quot;</span><span class="p">),</span> <span class="n">extra_new_instances</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">base_has_nonpred</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">extra_base_instances</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">base_predictions</span><span class="p">)</span>
            <span class="n">new_has_nonpred</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">extra_new_instances</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_predictions</span><span class="p">)</span>

            <span class="c1"># If they both have some predictions or they both have some</span>
            <span class="c1"># non-predictions, then there is a conflict.</span>
            <span class="c1"># (Otherwise it&#39;s not a conflict since we can cleanly merge</span>
            <span class="c1"># all the predicted instances with all the non-predicted.)</span>
            <span class="k">if</span> <span class="n">base_predictions</span> <span class="ow">and</span> <span class="n">new_predictions</span><span class="p">:</span>
                <span class="n">conflict</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">base_has_nonpred</span> <span class="ow">and</span> <span class="n">new_has_nonpred</span><span class="p">:</span>
                <span class="n">conflict</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">conflict</span><span class="p">:</span>
            <span class="c1"># Conflict, so update base to just include non-conflicting</span>
            <span class="c1"># instances (perfect matches)</span>
            <span class="n">base_frame</span><span class="o">.</span><span class="n">instances</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">base_frame</span><span class="o">.</span><span class="n">instances</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">redundant_instances</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># No conflict, so include all instances in base</span>
            <span class="n">base_frame</span><span class="o">.</span><span class="n">instances</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">extra_new_instances</span><span class="p">)</span>
            <span class="n">merged_instances</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">extra_new_instances</span><span class="p">)</span>
            <span class="n">extra_base_instances</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">extra_new_instances</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Construct frames to hold any conflicting instances</span>
        <span class="n">extra_base</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">cls</span><span class="p">(</span>
                <span class="n">video</span><span class="o">=</span><span class="n">base_frame</span><span class="o">.</span><span class="n">video</span><span class="p">,</span>
                <span class="n">frame_idx</span><span class="o">=</span><span class="n">base_frame</span><span class="o">.</span><span class="n">frame_idx</span><span class="p">,</span>
                <span class="n">instances</span><span class="o">=</span><span class="n">extra_base_instances</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">extra_base_instances</span>
            <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>

        <span class="n">extra_new</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">cls</span><span class="p">(</span>
                <span class="n">video</span><span class="o">=</span><span class="n">new_frame</span><span class="o">.</span><span class="n">video</span><span class="p">,</span>
                <span class="n">frame_idx</span><span class="o">=</span><span class="n">new_frame</span><span class="o">.</span><span class="n">frame_idx</span><span class="p">,</span>
                <span class="n">instances</span><span class="o">=</span><span class="n">extra_new_instances</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">extra_new_instances</span>
            <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">merged_instances</span><span class="p">,</span> <span class="n">extra_base</span><span class="p">,</span> <span class="n">extra_new</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">image</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the image for this frame of shape (height, width, channels).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">video</span><span class="o">.</span><span class="n">get_frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_idx</span><span class="p">)</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">SLEAP</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial-part2.html">Tutorial, Part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../howtos.html">How-Tos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference.html">Feature Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Murthy Lab @ Princeton.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>